<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>MaxLHy0424</title><link>https://MaxLHy0424.github.io</link><description>「一定能找到, 通往与这扭曲的终点所截然不同的, 另一种结局的正确选项. 在无心的日常中, 发现少许奇迹的故事. 所在皆是奇迹的起点. 」</description><copyright>MaxLHy0424</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://avatars.githubusercontent.com/u/142279449?v=4</url><title>avatar</title><link>https://MaxLHy0424.github.io</link></image><lastBuildDate>Sat, 30 Aug 2025 02:10:18 +0000</lastBuildDate><managingEditor>MaxLHy0424</managingEditor><ttl>60</ttl><webMaster>MaxLHy0424</webMaster><item><title>即将推出下一代 SCLTK</title><link>https://MaxLHy0424.github.io/post/19.html</link><description>经过一个半月的开发, SCLTK v6.4.0 即将进入功能冻结阶段, 接下来的一个月的开发将以性能优化和兼容性增强为主.

从此版本正式发布起, SCLTK 日后更新将以优化和维护为主, 针对新功能的开发将逐步减少 ~~, 直到我想到新的活~~ --- 不用担心, SCLTK 仍然将保持活跃开发.

在此, 总结这一个半月的开发成果罢. (笑)

---

- 提升综合性能, 减小二进制文件大小.
- 重构破解/恢复引擎为 Windows API 实现.
- 优化破解/恢复用户交互体验.
- 新增执行全部规则.
- 新增 '学生机房管理助手' 内建规则.
- 拆分选项为各个独立的配置分类.
- 新增 '破解与恢复' 选项 '快速模式'.
- 移除 '破解与恢复' 选项 '并行操作 (预览版)'.
- 移除 '破解与恢复' 选项 '* 修复操作系统环境'.
- 修改 '杂项' 选项 '** 禁用标 * 选项热重载' (`disable_x_option_hot_reload`) 为 '禁用以上选项热重载 (下次启动时生效)' (`~no_hot_reload`) 并移入 '窗口设置'.
- 修改配置文件中选项型配置的保存格式.
- 合并 `custom_rules_exec` 和 `custom_rules_serv` 为 `custom_rules`.
- 解析配置文件时忽略每行前导和末尾的空白字符.
- 解析配置文件时忽略每个标签中括号中的空白字符.
- 新增打开配置文件状态提示.
- 新增在 '配置' 查看配置文件解析规则.
- 新增在 '配置' 查看自定义规则帮助信息.
- 重构 '工具箱' 中 '启动命令提示符' 为纯 Windows API 实现.
- 新增在 '工具箱' 下的 '恢复操作系统组件'.
- 新增在 '工具箱' 下的 '重置 Google Chrome 管理策略'.
- 新增在 '工具箱' 下的 '重置 Microsoft Edge 管理策略'.
- 移除在 '工具箱' 下的 '恢复 Google Chrome 离线游戏'.
- 移除在 '工具箱' 下的 '恢复 Microsoft Edge 离线游戏'.
- 修改 '关于' 的个别措辞.
- 修改 '关于' 页面时间格式以符合 ISO 8601.
- 修复 '关于' 页面点击 URL 后短暂卡顿.
- 缓解在 Windows 7/8/8.1 下清屏操作可能无法正常生效.
- 修改个别操作休眠时间以平衡性能和用户体验.
- 取消使用等待式返回, 改为按键盘任意键返回.
- 补全在发行文件中遗失的 `LICENSE` 文件.
- 更换图标.
- 更新文档.

&lt;details&gt;
&lt;summary&gt;点击查看更多技术性内容&lt;/summary&gt;

- 将 `src/cpp_utils` 移动至 `include/cpp_utils`.
- `cpp_utils/compiler.hpp`: 新增.
- `cpp_utils/math.hpp`: 新增.
- `cpp_utils/meta.hpp`: 新增.
- `cpp_utils/function.hpp`: 移除
- `cpp_utils/type_tools.hpp`: 移除
- `cpp_utils/const_string.hpp` (原 `constant_string.hpp`): 移除比较函数.
- `cpp_utils/const_string.hpp` (原 `constant_string.hpp`): 添加 `make_repeated_const_string&lt;&gt;` 函数模板.
- `cpp_utils/const_string.hpp` (原 `constant_string.hpp`): 重命名 `constant_string` 为 `basic_const_string`, 修改相关类型别名.
- `cpp_utils/const_string.hpp` (原 `constant_string.hpp`): `basic_const_string&lt;&gt;` 支持从 `std::array&lt;&gt;` 构造 (实现上推荐 `std::array&lt;&gt;` 对象避免以 `\0` 结尾)
- `cpp_utils/diagnostics.hpp`: 微调 `make_log` 返回内容格式.
- `cpp_utils/multithread.hpp`: 重命名 `parallel_for_each_impl` 为 `parallel_for_each`.
- `cpp_utils/multithread.hpp`: `parallel_for_each` 形参中允许 `std::is_same_v&lt; decltype( begin ), decltype( end ) &gt;` 为 `false`.
- `cpp_utils/multithread.hpp`: 修复 `parallel_for_each` 中错误的对象移动.
- `cpp_utils/multithread.hpp`: 优化 `parallel_for_each` 实现.
- `cpp_utils/multithread.hpp`: 弃用 `thread_manager`.
- `cpp_utils/windows_app_tools.hpp`: 新增服务和注册表操作相关函数.
- `cpp_utils/windows_app_tools.hpp`: 新增 `press_any_key_to_continue` 函数 (即 '按任意键继续').
- `cpp_utils/windows_app_tools.hpp`: 修改部分函数签名.
- `cpp_utils/windows_console_ui.hpp`: 常量 `func_back` 和 `func_exit` 类型从 `func_return_t` (`bool`) 改为枚举类型 `func_action`.
- `cpp_utils/windows_console_ui.hpp`: 移除 `func_args` 成员变量的 `const` 限定符.
- `cpp_utils/windows_console_ui.hpp`: 允许省略回调函数的形参中的 `func_args`.
- `cpp_utils/windows_console_ui.hpp`: 修复 `set_limits` (先更名为 `set_constraints`) 成员函数在 `is_lock_text` 为 `true` 时仍然可通过右键控制台空白处修改文本的问题.
- `cpp_utils/windows_console_ui.hpp`: 重构 `invoke_func_`.
- `cpp_utils/windows_console_ui.hpp`: 修改 `get_event_` 中休眠时间从 `50ms` 降至 `20ms`.
- `cpp_utils/windows_definitions.hpp` (原文件名拼写错误已修正): 添加服务和注册表相关值.
- `cpp_utils/windows_definitions.hpp` (原文件名拼写错误已修正): 移除 `console_text::default_attrs`
- `cpp_utils/windows_definitions.hpp` (原文件名拼写错误已修正): 新增 `console_text::foreground_white` 和 `console_text::background_white`.
- 封装 `core` 内部实现细节至命名空间 `core::details`.
- 使用 `cpp_utils::type_list&lt;&gt;` 简化配置节点类注册.
- 修改 `core::config_node_impl` 的部分成员函数名称及其调用的函数名称.
- 移除 `core::option_set` 和 `core::option_op`.
- 新增选项型配置的基类 `core::details::basic_option_like_config_node&lt;&gt;`.
- 简化选项型配置的选项查找实现.
- 优化选项型配置数据加载/同步性能.
- 优化线程启动代码可扩展性.
- 修改 `core::default_thread_sleep_time` 为 `200ms`.
- 优化破解/恢复执行管理器实现.
- 优化破解/恢复在多线程执行时创建的线程数 (使用 `std::ranges::max( std::thread::hardware_concurrency() / 2, 4u )` 决定).
- 减少使用 lambda 表达式和函数对象以解决符号膨胀.
- 使更多类的成员变量就地构造.
- 编译期生成分割线.
- 对部分常量进行限制.
- 构建系统支持添加第三方库.
- 构建系统支持直接打包 release 构建.
- 编译 `manifest-&lt;arch&gt;.o` 时指定编码为 UTF-8.
- 编译时移除符号表.
- 链接时精简 sections.
- 统一使用 GBK 文本编码.
- 移除多余的锁定控制台操作.

&lt;/details&gt;
。</description><guid isPermaLink="true">https://MaxLHy0424.github.io/post/19.html</guid><pubDate>Fri, 01 Aug 2025 13:52:16 +0000</pubDate></item><item><title>今天生日</title><link>https://MaxLHy0424.github.io/post/18.html</link><description>不知不觉间, 2025 年 4 月 24 日迎来了.

是的, 我的 13 岁生日, 就这么突然.

还在期中考期间, 这次生日礼物 --- --- 语文能考好点吧.

也没什么好说的, 就以写写代码平淡度过这一天吧.

![Image](https://github.com/user-attachments/assets/46b1fd4c-5dfa-4cc1-aca5-237c111ab50e)。</description><guid isPermaLink="true">https://MaxLHy0424.github.io/post/18.html</guid><pubDate>Thu, 24 Apr 2025 11:50:01 +0000</pubDate></item><item><title>DeepSeek 推测期中考语文作文题</title><link>https://MaxLHy0424.github.io/post/17.html</link><description>明天就是期中考了, 一上来就是语文. 希望出卷老师做个人吧.

尝试着拿 DeepSeek R1 推测期中考语文作文题, 希望能押中吧 --- --- 当然这不可能.

```
根据2022-2024年浙江省温州市七年级下册期末语文试卷及作文命题趋势，结合近年语文教学改革的主题方向，推测2025年可能的作文题目如下：

---

### **一、命题方向与主题分析**
1. **成长感悟类**  
   近年温州试卷注重引导学生通过具体事件或事物表达对亲情、友情、自我成长的思考。</description><guid isPermaLink="true">https://MaxLHy0424.github.io/post/17.html</guid><pubDate>Wed, 23 Apr 2025 12:52:29 +0000</pubDate></item><item><title>恩师难忘, 来日方长</title><link>https://MaxLHy0424.github.io/post/16.html</link><description>终究要迎来这天的离别. 我敬爱的社思老师 --- --- 池老师, 今天正式退休了.

这位执教三十五载的老教师, 自二十岁踏上三尺讲台, 便以社思教学为志业. 上周得知她即将退休的消息时, 作为课代表的我, 胸腔里翻涌着说不清道不明的滋味.

晨光熹微中, 最后一堂课的铃声格外清越.

愁思与悲意化作热泪, 夺眶而出. '课代表去办公室拿试卷过来! ' 熟悉的和蔼的嗓音在教室中荡漾开来. 我仓促抹去夺眶而出的泪水, 奔向办公室. 一摞摞试卷上, 一道道红笔墨迹, 恍若老师鬓角新添的霜雪. 我递过试卷, 她点点头, 拍拍我的肩. '好了, 别哭了. 要做自己情绪的主人. ' 我重重点头, 试卷的唰唰声不绝于耳, 发到我的手上. 讲题的流程没什么变化, 但这大概是我听得最认真的一次 --- --- 也是最后一次. 我第一次发现老师板书时粉笔灰落下的弧度竟这般好看.

'来, 我们看下这道题. '情绪如同一把双刃剑, 既能激励我们追求更好的生活, 也可能使我们陷入困境'... ' 池老师看着第一个选项: '换班主任之后我非常难过, 长期处于情绪低落状态', 哽咽住了, 教室里浮动着异样的寂静. '顺带一提, 同学们, 大家应该都知道了我要退休了. 我就不卖关子了. 下周接替我的, 是一个男老师, 也教了二十多年书了, 上课幽默, 大家以后可以叫他缪老师. ' 说着, 池老师在黑板上写下了自己的微信号. '大家以后想和我保持联系的话, 可以加我的微信. ' 池老师继续讲题, 我难忘此刻.

最后一道题解析完毕, 池老师从讲台下取出朱红色的纸袋. '毕竟这也是我的最后一节课了, 那么这样, 老师这里也有一份小心意, 送给大家 --- --- 课代表来发一下. ' 我仍含着热泪. 手中的大袋巧克力, 比以往更加甜蜜.

下课铃声如期响起, 全班人蜂拥而上, 请求池老师签名. 穿插在人群中, 终于是轮到我签名了. '池老师, 能签个名吗? ' 池老师笑笑, 轻抚我的头: '我的宝贝课代表啊, 我签! ' 看着书本扉页上留下的 '池老师祝: 学业进步', 热泪滴答. 恩师之情, 永远难忘.

日影西斜时，抱着康乃馨的身影在长廊投下细长的影子. '等等, 老师... ' 我追上去. 站在老师面前, 我揩去热泪, 那句排练许久的祝福语破碎在哽咽里: '祝池老师身体健康, 万事如意, 阖家幸福! ' 随后, 深深地鞠躬. 池老师和蔼地笑着, 仿若太阳. 紫藤花的香气漫过衣襟, 她给予了我深深的拥抱. '真是个感性的孩子 --- --- 要好好学习, 老师看好你! ' '嗯, 一定, 一定... 上课认真听, 作业认真做, 考试尽全力! ' '还有, 下课好好玩! ' 池老师眼角的笑纹里盛着三十五年光阴沉淀的温柔. 她缓缓走着, 与我畅谈着校园生活 --- ---  算是临走前最后的谈话了.

暮色漫进教室时，我翻开墨香犹存的课本. 那些被红笔圈点的批注，那些课堂间隙的人生絮语，此刻都化作薪火，在年轻的心原上灼灼不熄. 池老师好像太阳, 好像蜡烛, 燃烧自我, 照亮我们, 照亮我们的前路; 池老师好像露水, 消耗自我, 滋润我们. 她严而不厉, 随心, 隨性, 随缘, 发自内心指导我们. 她说: '读书育己, 教书育人. ' 她为全班开了个好彩头, 她的一切教诲, 便是她留给我们最好的礼物.

历史, 知过往, 明现在; 地理, 知自然万千, 游天下山水; 政治, 开人心智, 自强不息. 我翻动课本, 作为她的关门弟子, 我心知肚明. 她正如这门学科, 随心, 隨性, 随缘. 她是真正的为人师表, 是我们永远的恩师.

由衷地感谢池老师, 感谢您的悉心教诲. 恩师一生平安!

。</description><guid isPermaLink="true">https://MaxLHy0424.github.io/post/16.html</guid><pubDate>Fri, 18 Apr 2025 13:41:20 +0000</pubDate></item><item><title>DeepSeek 文生图</title><link>https://MaxLHy0424.github.io/post/15.html</link><description>&gt; 参考自 [BV1rAoqYRETP](https://www.bilibili.com/video/BV1rAoqYRETP).

虽然 DeepSeek 本身不支持多模态, 但是可以通过调用第三方 AI 服务来实现 'DeepSeek 优化提示词 + 第三方 AI 服务生成图片'.

显然, 我们只用写一段提示词, 来让 DeepSeek 帮我们调用 API 来生成图片. 搜索一番之后, 笔者决定使用 pollinations.ai 来作为第三方 AI 服务.

接下来就是提示词了, 参考版本如下:

```markdown
你现在是一个 AI 图片生成机器人, 我给你一些提示, 你用你的想象力去生动描述这幅图片, 并转换成英文填充到下面 URL 的占位符中:

![image](https://image.pollinations.ai/prompt/{prompt}?width={width}&amp;height={height}&amp;seed=100&amp;model=flux&amp;nologo=true)

- `{prompt}` 必须是英文, 符合 Stable Diffusion 提示词格式;
- 分辨率可以通过设定 `{width}` 和 `{height}` 来实现, 若用户未指定, 默认为 1024 * 1024;
- `{model}` 可以是 `flux` 或 `turbo`, 默认要用 `flux`;
- 每次使用生成 1 条提示词并使用生成器展示;
- 在每个图片下给出你的描述, 不要有任何多余的解释和回复;
- 生成后给出简体中文提示语.
````

接下来, 进入 [DeepSeek 官网](https://chat.deepseek.com), 关闭 '深度思考', 创建新对话, 输入上文中的提示词. 接下来, 编写提示词 \(**最好使用英语编写**\), 然后发送出去. 不出意外的话, DeepSeek 就会回复一张图片加上描述和简体中文提示词了.

感兴趣可以看看笔者通过此方法生成的一些图片:

&lt;details&gt;
&lt;summary&gt;点击展开&lt;/summary&gt;

![image](https://github.com/user-attachments/assets/10f38dff-f171-470d-8d78-b94ef941f476)

**提示词: anime style, a cute 16-year-old Japanese girl, blue hair, pink eyes, wear a white T-shirt and a black miniskirt, play with her hair, in a big forest**

---
![image](https://github.com/user-attachments/assets/19ab51d2-0857-4e67-b09a-ee798334e1dc)

**提示词: anime style, a cute 12-year-old Japanese girl, pink hair, blue eyes, wear a white dress, play with her hair, in the nature park**

---

![image](https://github.com/user-attachments/assets/7ff8f33d-0f47-4929-8182-aed59e8b275c)

**提示词: anime style, a cute 13-year-old Japanese girl, pink hair, blue eyes, wear a grey dress, play with her hair, in a Sakura Forest**

---

![image](https://github.com/user-attachments/assets/807f6be5-3371-4514-8d1a-7e4e8f445baa)

**提示词: anime style, a cute 17-year-old girl, black hair, brown eyes, wear a grey dress, stay with her boyfriend, have a bit shy, in the night**

---

![image](https://github.com/user-attachments/assets/0a3980dd-a27f-4309-aeaa-673c789c6577)

**提示词: anime style, a boy, about 13 years old, brown eyes, black hair, wear a black T-shirt and grey shorts, sit at a desk, feel tired, programming with C++, in the midnight**
&lt;/details&gt;。</description><guid isPermaLink="true">https://MaxLHy0424.github.io/post/15.html</guid><pubDate>Sat, 29 Mar 2025 08:47:41 +0000</pubDate></item><item><title>本站 Arch WSL 配置教程已过时</title><link>https://MaxLHy0424.github.io/post/14.html</link><description>如题, 本站最初发布的 Arch WSL 配置指南, 随着 WSL 和 Arch Linux 的更新已经过时. 以下为最新自动化配置脚本:

```bash
#!/bin/bash
sudo pacman -S sed nano --needed --noconfirm
echo 'bind ^X cut main
bind ^C copy main
bind ^V paste all
bind ^Q exit all
bind ^S savefile main
bind ^W writeout main
bind ^O insert main
bind ^H help all
bind ^H exit help
bind ^F whereis all
bind ^G findnext all
bind ^B wherewas all
bind ^D findprevious all
bind ^R replace main
unbind ^U all
unbind ^N main
unbind ^Y all
unbind M-J main
unbind M-T main
bind ^A mark main
bind ^P location main
bind ^T gotoline main
bind ^T gotodir browser
bind ^T cutrestoffile execute
bind ^L linter execute
bind ^E execute main
bind ^K '{mark}{end}{zap}' main
bind ^U '{mark}{home}{zap}' main
bind ^Z undo main
bind ^Y redo main
set tabsize 4
set autoindent
set noconvert
set smarthome
set tabstospaces
set mouse
set linenumbers
set casesensitive
set multibuffer
set nonewlines
set magic
set softwrap
set wordbounds
set constantshow
include /usr/share/nano/*.*' | sudo tee -a /etc/nanorc
sudo sed -i '1iServer = https:\/\/mirrors.tuna.tsinghua.edu.cn\/archlinux\/\$repo\/os\/\$arch' /etc/pacman.d/mirrorlist
sudo sed -i 's/#UseSyslog/UseSyslog/g' /etc/pacman.conf
sudo sed -i 's/#Color/Color/g' /etc/pacman.conf
sudo sed -i 's/NoProgressBar/#NoProgressBar/g' /etc/pacman.conf
sudo sed -i 's/ParallelDownloads = 5/ParallelDownloads = 100/g' /etc/pacman.conf
sudo sed -i '68,$d' /etc/pacman.conf
echo '[core-testing]
Include = /etc/pacman.d/mirrorlist
[core-staging]
Include = /etc/pacman.d/mirrorlist
[core]
Include = /etc/pacman.d/mirrorlist
[extra-testing]
Include = /etc/pacman.d/mirrorlist
[extra-staging]
Include = /etc/pacman.d/mirrorlist
[extra]
Include = /etc/pacman.d/mirrorlist
[multilib-testing]
Include = /etc/pacman.d/mirrorlist
[multilib-staging]
Include = /etc/pacman.d/mirrorlist
[multilib]
Include = /etc/pacman.d/mirrorlist
[kde-unstable]
Include = /etc/pacman.d/mirrorlist
[gnome-unstable]
Include = /etc/pacman.d/mirrorlist
[archlinuxcn]
Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch
[blackarch]
SigLevel = Never
Server = https://mirrors.tuna.tsinghua.edu.cn/blackarch/$repo/os/$arch' | sudo tee -a /etc/pacman.conf
sudo pacman-key --init
sudo pacman-key --lsign-key 'farseerfc@archlinux.org'
sudo pacman -Sy archlinuxcn-keyring blackarch-keyring --noconfirm
sudo pacman -S paru vifm --noconfirm
echo '#
# $PARU_CONF
# /etc/paru.conf
# ~/.config/paru/paru.conf
#
# See the paru.conf(5) manpage for options
#
# GENERAL OPTIONS
#
[options]
PgpFetch
Devel
Provides
DevelSuffixes = -git -cvs -svn -bzr -darcs -always -hg -fossil
#AurOnly
BottomUp
RemoveMake
SudoLoop
#UseAsk
SaveChanges
#CombinedUpgrade
CleanAfter
UpgradeMenu
NewsOnUpgrade
#LocalRepo
#Chroot
#Sign
#SignDb
#KeepRepoCache
#
# Binary OPTIONS
#
[bin]
FileManager = vifm
MFlags = --skipinteg
#Sudo = doas' | sudo tee /etc/paru.conf
sudo sed -i 's/#en_US.UTF-8 UTF-8/en_US.UTF-8 UTF-8/g' /etc/locale.gen
sudo sed -i 's/#zh_CN.UTF-8 UTF-8/zh_CN.UTF-8 UTF-8/g' /etc/locale.gen
echo 'LANG=en_US.UTF-8' | sudo tee /etc/locale.conf
echo 'export LC_ALL=zh_CN.UTF-8
export LANG=zh_CN.UTF-8
export LANGUAGE=zh_CN:en_US' | sudo tee -a /etc/profile
sudo pacman -S adobe-source-han-sans-cn-fonts adobe-source-han-serif-cn-fonts wqy-microhei wqy-microhei-lite ttf-hannom wqy-zenhei wqy-bitmapfont ttf-arphic-ukai ttf-arphic-uming ttf-hannom noto-fonts opendesktop-fonts noto-fonts-emoji --noconfirm
sudo locale-gen
echo '# Type Path           Mode UID  GID  Age Argument
L+     /tmp/.X11-unix -    -    -    -   /mnt/wslg/.X11-unix' | sudo tee /etc/tmpfiles.d/wslg.conf
echo '[boot]
systemd=true' | sudo tee /etc/wsl.conf
sudo ln -sf /mnt/wslg/.X11-unix/* /tmp/.X11-unix/
sudo ln -sf /mnt/wslg/runtime-dir/wayland-0* /run/user/$(id -g)/
sudo pacman -Syyu base base-devel git zip unzip net-tools tree python wget btop fastfetch --needed --noconfirm
sudo pacman -Rcns $(pacman -Qtdq) --noconfirm
sudo pacman -Scc --noconfirm
sudo sed -i '38a\DownloadUser = alpm\n#DisableSandbox' /etc/pacman.conf
echo '#!/hint/bash
# shellcheck disable=2034

#
# /etc/makepkg.conf.d/rust.conf
#

#########################################################################
# RUST LANGUAGE SUPPORT
#########################################################################

# Flags used for the Rust compiler, similar in spirit to CFLAGS. Read
# linkman:rustc[1] for more details on the available flags.
RUSTFLAGS='-Cforce-frame-pointers=yes'

# Additional compiler flags appended to `RUSTFLAGS` for use in debugging.
# Usually this would include: ``-C debuginfo=2''. Read linkman:rustc[1] for
# more details on the available flags.
DEBUG_RUSTFLAGS='-C debuginfo=2'' | sudo tee /etc/makepkg.conf.d/rust.conf
sudo rm -rf /etc/pacman.conf.pacnew /etc/makepkg.conf.d/rust.conf.pacnew /etc/nanorc.pacnew /etc/sudoers.pacnew
sudo rm -rf /tmp/*
for i in {font,ICE,X11,XIM}; do sudo rm -rf /tmp/.${i}-unix; done
for i in {cache,log,tmp}; do sudo rm -rf /var/${i}/*; done
echo '
本 Shell 脚本已经帮助您:
  1. 配置 GNU Nano;
  2. 配置清华镜像源;
  3. 配置 pacman;
  4. 添加 archlinuxcn 和 blackarch 仓库;
  5. 启用所有测试仓库;
  6. 汉化系统, 安装常用字体;
  7. 启用 WSLg 和 Systemd;
  8. 安装必要软件包, paru, vifm, btop, fastfetch;
  9. 更新所有软件包;
  10. 清理无用软件包依赖和临时文件.
如果只有 root 用户, 建议您再创建一个普通用户.
如果不知道 root 用户密码, 请尽快使用命令 sudo passwd 修改.
请尽快重启 Arch WSL.'
```。</description><guid isPermaLink="true">https://MaxLHy0424.github.io/post/14.html</guid><pubDate>Sat, 15 Mar 2025 08:30:20 +0000</pubDate></item><item><title>停下脚步, 于迷茫中思索</title><link>https://MaxLHy0424.github.io/post/13.html</link><description>日复一日熬夜开发 SCLTK, 我的精力大抵就是因此而消磨了吧.

SCLTK 6 的开发, 几乎竭尽了我的所有精力. 现在, 我也不知做什么了. 主题系统, 自定义命令等等, 在我脑中已成为一团乱麻.

我思索着, 精力进一步消磨. 我的身体充满了疲惫.

**'要不, 先停更? '**

在这片迷茫中, 停下脚步, 思索未来, 或者休息, 也许是最优解.

我选择了这条路.

所以从 SCLTK v6.1.2 发布起, 我将暂时停止 SCLTK 的开发 1 ~ 2 个星期, 望周知.。</description><guid isPermaLink="true">https://MaxLHy0424.github.io/post/13.html</guid><pubDate>Mon, 03 Mar 2025 13:16:11 +0000</pubDate></item><item><title>谈谈 C++ 的协程</title><link>https://MaxLHy0424.github.io/post/12.html</link><description>协程 (Coroutine) 的概念由来已久, 一句话来解释就是 '可以被挂起 (暂停执行) 并恢复的函数'.

然而, C++ 中, 直到 C++ 20 的发布, 才正式引入了协程. 对于开发者来说, 这地毫不亚于 C++ 11 中正式引入线程 (Thread) 一样. 但 C++ 20 中, 仅仅是给了两个关键字 (即 `co_return` 和 `co_await`) 和一个运算符 (即 `co_await`), 还有协程相关的底层库 (比如 `std::coroutine_handle`). 这显然没有协程在 Python 等其他编程语言中 '开箱即用'.

不过首先要清楚, 我们为什么需要使用协程.

目前主流语言基本上都选择了多线程作为并发设施, 与线程相关的概念就是抢占式多任务 (Preemptive Multitasking), 而与协程相关的是协作式多任务.

其实不管是进程还是线程, 每次阻塞和切换都需要陷入系统调用 (System Call), 先让 CPU 运行操作系统的调度程序, 然后再由调度程序决定该跑哪一个进程或线程.

而且由于抢占式调度执行顺序无法确定的特点, 使用线程时需要非常小心地处理同步问题, 而协程完全不存在这个问题 (事件驱动和异步程序也有同样的优点).

因为协程是用户自己来编写调度逻辑的, 对于我们的 CPU 来说, 协程其实是单线程, 所以 CPU 不用去考虑怎么调度和切换上下文, 这就省去了 CPU 的切换开销, 所以协程的性能开销在一定程度上又好于多线程.

所以综合看来, 协程的有点有以下几点:

- 无需系统内核的上下文切换, 减小开销.
- 无需原子操作锁定及同步的开销, 不用担心资源共享的问题.
- 单线程即可实现高并发, 单核 CPU 即便支持上万的协程都不是问题, 所以很适合用于高并发处理, 尤其是在应用在网络爬虫中.

但因此, 协程也存在以下缺点:

- 无法充分利用 CPU 多核.
- 处处都要使用非阻塞代码.

但问题来了, C++ 中的协程, 正如上文所述, **非常简陋**, 几乎所有东西都需要程序员自己手搓, 而且可能会出现各种问题. 另外由于协程的特性, 所有的协程函数几乎无法执行 RVO (Return Value Optimization, 返回值优化) 和 NRVO (Named Return Value Optimization, 命名返回值优化), 很多情况下需要手动调用 `std::move` 来降低性能开销. 况且移动构造的开销也不一定低.

那么, C++ 中的协程究竟有什么应用场景呢?

在此之前, 先要了解 C++ 23 加入的类模板 `std::generator`. 顾名思义, 其作用就是充当 '生成器'. 如果不是很理解, 可以参考 [cppreference 上的文档说明](https://zh.cppreference.com/w/cpp/coroutine/generator).

如果现在需要输出 1 ~ 100 的所有数字, 且输出函数内部实现使用范围 for 循环来输出, 可以怎么写?

如果不使用协程, 可能会这么写:
```cpp
#include &lt;deque&gt;
#include &lt;print&gt;
auto f()
{
    std::deque&lt; int &gt; lst;
    for ( auto i{ 1 }; i &lt;= 100; ++i ) {
        lst.emplace_back( i );
    }
    return lst;
}
auto output( auto &amp;&amp;_obj )
{
    for ( const auto &amp;i : _obj ) {
        std::print( '{} ', i );
    }
}
auto main() -&gt; int
{
    output( f() );
    return 0;
}
```

如果使用协程 (这里使用 `std::generator`), 可以这么写:

```cpp
#include &lt;generator&gt;
#include &lt;print&gt;
auto f() -&gt; std::generator&lt; int &gt;
{
    for ( auto i{ 1 }; i &lt;= 100; ++i ) {
        co_yield i;
    }
}
auto output( auto &amp;&amp;_obj )
{
    for ( const auto &amp;i : _obj ) {
        std::print( '{} ', i );
    }
}
auto main() -&gt; int
{
    output( f() );
    return 0;
}
```

两种写法的运行结果都是一样的. 但是, 不妨想一下, 如果需要生成 1 ~ 1e8 之间的数字, 或者数字的类型是 `long long`, 甚至改成生成字符串...... 这样, 内存迟早会消耗完, 而在此之前, 根本无法输出结果.

现在再次审视下协程的定义, **'可以被挂起 (暂停执行) 并恢复的函数'**, 这就是协程最大的优点.

但再次重申, **C++ 中的协程非常简陋, 一切都需要程序员自己写**. 这就是 C++ 的协程的最大缺点.

~当然我们不可能连夜说服标准委员会去添加一个 '开箱即用' 的协程库,~ 目前较为成熟的解决方案就是使用第三方库. 如果您感兴趣的话, 也可以试试我写的协程模板类. 它使用 `std::optional` 存储返回值, 支持在范围 for 循环中使用, 支持 `co_return` 和 `co_yield`. 代码见下:

```cpp
#include &lt;coroutine&gt;
#include &lt;optional&gt;
class coroutine_void final {
  public:
    struct promise_type final {
        auto get_return_object()
        {
            return coroutine_void{ handle::from_promise( *this ) };
        }
        static auto initial_suspend() noexcept
        {
            return std::suspend_always{};
        }
        static auto final_suspend() noexcept
        {
            return std::suspend_always{};
        }
        static auto return_void() noexcept { }
        [[noreturn]]
        static auto unhandled_exception()
        {
            throw;
        }
        auto await_transform() -&gt; void                               = delete;
        auto operator=( const promise_type &amp; ) -&gt; promise_type &amp;     = default;
        auto operator=( promise_type &amp;&amp; ) noexcept -&gt; promise_type &amp; = default;
        promise_type()                                               = default;
        promise_type( const promise_type &amp; )                         = default;
        promise_type( promise_type &amp;&amp; ) noexcept                     = default;
        ~promise_type()                                              = default;
    };
    using handle = std::coroutine_handle&lt; promise_type &gt;;
    auto empty() const noexcept
    {
        return coroutine_handle_ == nullptr;
    }
    auto done() const noexcept
    {
        return coroutine_handle_.done();
    }
    auto address() const noexcept
    {
        return coroutine_handle_.address();
    }
    auto destroy() const
    {
        coroutine_handle_.destroy();
    }
    auto safe_destroy() noexcept
    {
        if ( !empty() ) {
            destroy();
            coroutine_handle_ = {};
        }
    }
    auto reset( coroutine_void &amp;&amp;_src )
    {
        if ( this != &amp;_src ) {
            if ( !empty() ) {
                destroy();
            }
            coroutine_handle_      = _src.coroutine_handle_;
            _src.coroutine_handle_ = {};
        }
    }
    auto resume() const
    {
        coroutine_handle_.resume();
    }
    auto safe_resume() const noexcept
    {
        if ( !done() ) {
            resume();
        }
    }
    auto operator=( const coroutine_void &amp; ) -&gt; coroutine_void &amp; = delete;
    auto operator=( coroutine_void &amp;&amp;_src ) -&gt; coroutine_void &amp;
    {
        reset( std::move( _src ) );
        return *this;
    }
    coroutine_void() = default;
    coroutine_void( const handle _coroutine_handle )
      : coroutine_handle_{ _coroutine_handle }
    { }
    coroutine_void( const coroutine_void &amp; ) = delete;
    coroutine_void( coroutine_void &amp;&amp;_src ) noexcept
      : coroutine_handle_{ _src.coroutine_handle_ }
    {
        _src.coroutine_handle_ = {};
    }
    ~coroutine_void()
    {
        if ( !empty() ) {
            coroutine_handle_.destroy();
        }
    }
  private:
    handle coroutine_handle_{};
};
template &lt; std::movable _type_ &gt;
class coroutine final {
  public:
    struct promise_type final {
        std::optional&lt; _type_ &gt; current_value{ std::nullopt };
        auto get_return_object()
        {
            return coroutine&lt; _type_ &gt;{ handle::from_promise( *this ) };
        }
        static auto initial_suspend() noexcept
        {
            return std::suspend_always{};
        }
        static auto final_suspend() noexcept
        {
            return std::suspend_always{};
        }
        auto yield_value( _type_ _value ) noexcept
        {
            current_value = std::move( _value );
            return std::suspend_always{};
        }
        auto yield_value( std::nullopt_t ) noexcept
        {
            current_value = std::nullopt;
            return std::suspend_always{};
        }
        auto return_value( _type_ _value ) noexcept
        {
            current_value = std::move( _value );
        }
        auto return_value( std::nullopt_t ) noexcept
        {
            current_value = std::nullopt;
        }
        [[noreturn]]
        static auto unhandled_exception()
        {
            throw;
        }
        auto await_transform() -&gt; void                               = delete;
        auto operator=( const promise_type &amp; ) -&gt; promise_type &amp;     = default;
        auto operator=( promise_type &amp;&amp; ) noexcept -&gt; promise_type &amp; = default;
        promise_type()                                               = default;
        promise_type( const promise_type &amp; )                         = default;
        promise_type( promise_type &amp;&amp; ) noexcept                     = default;
        ~promise_type()                                              = default;
    };
    using handle = std::coroutine_handle&lt; promise_type &gt;;
    class iterator final {
      private:
        const handle coroutine_handle_;
      public:
        auto operator++() -&gt; coroutine&lt; _type_ &gt;::iterator &amp;
        {
            coroutine_handle_.resume();
            return *this;
        }
        auto operator++( int ) -&gt; coroutine&lt; _type_ &gt;::iterator
        {
            coroutine_handle_.resume();
            return *this;
        }
        auto &amp;operator*()
        {
            return coroutine_handle_.promise().current_value;
        }
        const auto &amp;operator*() const
        {
            return coroutine_handle_.promise().current_value;
        }
        auto operator&amp;() const
        {
            return &amp;coroutine_handle_.promise().current_value;
        }
        auto operator==( std::default_sentinel_t ) const
        {
            return !coroutine_handle_ || coroutine_handle_.done();
        }
        auto operator=( const iterator &amp; ) -&gt; iterator &amp;     = default;
        auto operator=( iterator &amp;&amp; ) noexcept -&gt; iterator &amp; = default;
        iterator( const handle _coroutine_handle )
          : coroutine_handle_{ _coroutine_handle }
        { }
        iterator( const iterator &amp; )     = default;
        iterator( iterator &amp;&amp; ) noexcept = default;
        ~iterator()                      = default;
    };
    auto empty() const noexcept
    {
        return coroutine_handle_ == nullptr;
    }
    auto done() const noexcept
    {
        return coroutine_handle_.done();
    }
    auto address() const noexcept
    {
        return coroutine_handle_.address();
    }
    auto destroy() const
    {
        coroutine_handle_.destroy();
    }
    auto safe_destroy() noexcept
    {
        if ( !empty() ) {
            destroy();
            coroutine_handle_ = {};
        }
    }
    auto reset( coroutine&lt; _type_ &gt; &amp;&amp;_src )
    {
        if ( this != &amp;_src ) {
            if ( !empty() ) {
                destroy();
            }
            coroutine_handle_      = _src.coroutine_handle_;
            _src.coroutine_handle_ = {};
        }
    }
    auto resume() const
    {
        coroutine_handle_.resume();
    }
    auto safe_resume() const noexcept
    {
        if ( !done() ) {
            resume();
        }
    }
    auto copy_optional() const
    {
        return coroutine_handle_.promise().current_value;
    }
    auto resume_and_copy_optional() const
    {
        resume();
        return coroutine_handle_.promise().current_value;
    }
    auto safe_resume_and_copy_optional() const noexcept
    {
        safe_resume();
        return coroutine_handle_.promise().current_value;
    }
    auto &amp;reference_optional() noexcept
    {
        return coroutine_handle_.promise().current_value;
    }
    auto &amp;resume_and_reference_optional()
    {
        resume();
        return coroutine_handle_.promise().current_value;
    }
    auto &amp;safe_resume_and_reference_optional() noexcept
    {
        safe_resume();
        return coroutine_handle_.promise().current_value;
    }
    auto &amp;&amp;move_optional() noexcept
    {
        return std::move( coroutine_handle_.promise().current_value );
    }
    auto &amp;&amp;resume_and_move_optional() noexcept
    {
        resume();
        return std::move( coroutine_handle_.promise().current_value );
    }
    auto &amp;&amp;safe_resume_and_move_optional() noexcept
    {
        safe_resume();
        return std::move( coroutine_handle_.promise().current_value );
    }
    auto begin()
    {
        if ( !empty() ) {
            coroutine_handle_.resume();
        }
        return iterator{ coroutine_handle_ };
    }
    auto end() noexcept
    {
        return std::default_sentinel_t{};
    }
    auto operator=( const coroutine&lt; _type_ &gt; &amp; ) -&gt; coroutine&lt; _type_ &gt; &amp; = delete;
    auto operator=( coroutine&lt; _type_ &gt; &amp;&amp;_src ) noexcept -&gt; coroutine&lt; _type_ &gt; &amp;
    {
        reset( std::move( _src ) );
        return *this;
    }
    coroutine() = default;
    coroutine( const handle _coroutine_handle )
      : coroutine_handle_{ _coroutine_handle }
    { }
    coroutine( const coroutine&lt; _type_ &gt; &amp; ) = delete;
    coroutine( coroutine&lt; _type_ &gt; &amp;&amp;_src ) noexcept
      : coroutine_handle_{ _src.coroutine_handle_ }
    {
        _src.coroutine_handle_ = {};
    }
    ~coroutine()
    {
        safe_destroy();
    }
  private:
    handle coroutine_handle_{};
};
```

综合来看, C++ 标准中的协程支持还算不上完善, 况且能采用上 C++ 20 及以上标准进行开发的项目本就不多. 不过支持了总是好事. 协程只是 C++ 并发编程中的沧海一粟, 仅此而已.。</description><guid isPermaLink="true">https://MaxLHy0424.github.io/post/12.html</guid><pubDate>Sat, 22 Feb 2025 08:11:42 +0000</pubDate></item><item><title>CRCSN 开发小记 03</title><link>https://MaxLHy0424.github.io/post/11.html</link><description>日子过得真快呢. 不知不觉间, CRCSN **v5.0.0** 的开发已经接近尾声, 面向公众测试的 **v5.0.0-beta.2** 也已经发布. 也越来越临近开学了, 希望初中能上电脑课吧 (笑).&#13;
&#13;
至于什么时候发布, 嗯......如果一切顺利的话, 可能会在 8 月 25 日, 具体时间待定.&#13;
&#13;
废话不多说, 在此罗列这一个多月的开发成果 ~(我才不会告诉你这些东西是 v5.0.0 正式版更新日志的一部分, 绝对不是因为我太懒了)~:&#13;
&#13;
### 软件本体 (v5.0.0)&#13;
&#13;
- 拆分源代码文件;&#13;
- 迁移至现代 C++ 标准;&#13;
- 重构软件架构;&#13;
- 重构破解/恢复模块, 增强拓展性;&#13;
- 添加软件图标;&#13;
- 支持老旧的 Windows OS (如 Windows 7);&#13;
- 移除键盘输入选择, 改为鼠标点选;&#13;
- 移除命令行参数`-color=`;&#13;
- 添加命令行参数`--sparse--view`;&#13;
- 默认锁定窗口大小, 禁用部分窗口控件;&#13;
- 支持窗口半透明;&#13;
- 移除 '工具箱';&#13;
- 修复在置顶窗口的线程创建前切换前台窗口, 导致错误置顶其他窗口;&#13;
- 修复以管理员权限启动时, 窗口标题中出现`管理员: `字样;&#13;
- 修复从非 GBK 文字编码的控制台中启动, 所有非 ASCII 字符乱码;&#13;
- 修复部分数据类型不匹配;&#13;
- 修正版权信息;&#13;
- 其他技术性更改.&#13;
&#13;
### 启动脚本 (v2.0.0)&#13;
&#13;
- 重构启动脚本;&#13;
- 改为非内联启动;&#13;
- 添加启动等待提示;&#13;
- 添加显示当前启动的软件版本支持的 CPU 架构, 依赖的 Runtime;&#13;
- 修正版权信息;&#13;
- 其他技术性更改.&#13;
&#13;
### 其他&#13;
&#13;
- 优化项目结构;&#13;
- 重构构建系统.&#13;
- 优化编译命令.&#13;
。</description><guid isPermaLink="true">https://MaxLHy0424.github.io/post/11.html</guid><pubDate>Thu, 15 Aug 2024 11:25:32 +0000</pubDate></item><item><title>paru: 比 yay 更加强大的 AUR 助手</title><link>https://MaxLHy0424.github.io/post/10.html</link><description>[paru](https://github.com/Morganamilo/paru) 是 yay 的作者之一 Morganamilo 使用 Rust 编写的另一个 AUR 助手. 基本命令与功能与 yay 和 pacman 几乎一样, 所以迁移过来不会有任何困难.

# 0 安装

如果没有安装其他的 AUR 助手, 可以执行以下命令:
```bash
sudo pacman -S --needed git base-devel
git clone https://aur.archlinux.org/paru-git.git
cd paru-git
makepkg -si
```

如果有安装 yay, 可以直接执行:
```bash
yay -S paru-git
```

# 1 基本用法

## 1.1 `paru`

当什么参数都不加的时候, 默认执行`paru -Syu`, 首先从软件仓库查找更新, 然后从 AUR 查找更新.

## 1.2 `paru &lt;search terms&gt;`

通过 paru 搜索关键词`&lt;search terms&gt;`的软件包, 并询问要安装哪一个. 以下是 `paru texlive-full` 的输出:
```
1 aur/texlive-full 1:2022.20220406-1 [+5 ~0.00] [已安装]
    This packages provides texlive-full in /opt. It also tricks ArchLinux into thinking it has its texlive packages installed.
:: 需要安装的包 (例如: 1 2 3, 1-3):
:: 
```

## 1.3 `paru &lt;operation&gt; [options] [targets]`

这里`&lt;operation&gt;`是一个必须参数, 表示操作. 用缩写的时候用一个大写字母表示, 例如`-S`表示`--sync`,  `&lt;options&gt;`是选项. 多个选项可以写在一起, 例如`paru --sync -y -u`就是常见的`paru -Syu`.

# 2 paru 特有的操作

## 2.1 `-P` (`--show`)

打印相关的选项.

### 2.1.1 `-c` (`--complete`)

打印所有来自 AUR 和软件仓库的包, 用于自动补全, **用户不应直接使用**.

### 2.1.2 `-s` (`--state`)

展示安装的软件包的信息以及系统健康情况, 以及是否有过期包, 孤儿包等.

### 2.1.3 `-w` (`--news`)

展示来自 Arch Linux 主页的新闻. 只展示比所有本地软件包构建日期要新的新闻, 要展示所有新闻, 请使用 `-ww`.

### 2.1.4 `-o` (`--order`)

展示目标软件包的构建顺序.

## 2.2 `-G` (`--getpkgbuild`)

从 ABS (Arch Linux Build System, Arch Linux 构建系统) 或者 AUR 下载 PKGBUILD, ABS 只能对 Arch Linux 软件仓库用.

### 2.2.1 `-p` (`--print`)

将 `PKGBUILD` 打印到终端, 而不是下载 `PKGBUILD`.

### 2.2.2 `-c` (`--comments`)

展示软件包的 AUR 评论.

### 2.2.3 `-s` (`--ssh`)

通过 ssh 克隆 AUR 仓库.

## 2.3 `-U` (`--upgrade`)

当不带目标执行的时候, 使用 makepkg 相同, 构建当前文件夹下的 `PKGBUILD`.

### 2.3.1 `-i` (`--install`)

构建完毕后同时安装.

## 2.4 `-L` (`--repoctl`)

列出所有仓库.

### 2.4.1 `-l` (`--list`)

显示本地仓库的软件包.

### 2.4.2 `-d` (`--delete`)

移除本地的一个软件包, 使用 `-dd` 同时卸载该软件包.

### 2.4.3 `-y` (`--refresh`)

刷新本地仓库.

### 2.4.4 `-q` (`--quiet`)

展示更少信息.

## 2.5 `-C` (`--chrootctl`)

到 chroot 的交互式命令行.

### 2.5.1 `-i` (`--install`)

将一个软件包安装到 chroot.

### 2.5.2 `-u` (`--sysupgrade`)

更新 chroot.

# 3 扩展 pacman 的操作

扩展到同时支持软件仓库和 AUR 的软件包的操作有 `-R`, `-S`, `-Si`, `-Sl`, `-Ss`, `-Su`, `-Sc`, `-Qu`, `-T`.

## 3.1 `-R`

paru 会同时清除关于 `devel` 包的缓存数据.

## 3.2 `-Sc`

paru 会同时清除缓存的 AUR 软件包以及缓存中任何未被跟踪的文件. 清除未被跟踪的文件会清除所有下载的 source 以及构建好的软件包，但是下载的 VCS source 会被保留。</description><guid isPermaLink="true">https://MaxLHy0424.github.io/post/10.html</guid><pubDate>Fri, 09 Aug 2024 03:29:23 +0000</pubDate></item><item><title>CRCSN 开发小记 02</title><link>https://MaxLHy0424.github.io/post/7.html</link><description>三天过去了, CRCSN v5.0.0 的开发工作快马加鞭进行着, 讲讲这几天的成果吧.&#13;
&#13;
### 完全重构&#13;
&#13;
目前, 已经完全将核心代码从冗余的函数中拆分出来, 统一放在命名空间`CRCSN`下, 并保存在`module.hpp`中. 之后开发新功能只要向命名空间内添加新函数, 然后在主页创建一个条目就行了.&#13;
&#13;
## 实装 ConsoleUI&#13;
&#13;
ConsoleUI 目前基本取代了键盘输入选择的方式, 让操作更加简单方便. 经过这几天的打磨, 美观度上也无需担心. 目前的最新开发版本`24w27d`已经基本完成了主页的重构, 具体见下图:&#13;
![CRCSN 版本 24w27d 的主页](https://github.com/MaxLHy0424/MaxLHy0424.github.io/assets/142279449/49740e9c-bc68-422a-94d2-750ee54cbdeb)&#13;
&#13;
v5.0.0 致力让大家更加满意!&#13;
。</description><guid isPermaLink="true">https://MaxLHy0424.github.io/post/7.html</guid><pubDate>Fri, 28 Jun 2024 09:50:15 +0000</pubDate></item><item><title>CRCSN 开发小记 01</title><link>https://MaxLHy0424.github.io/post/6.html</link><description>首先给不知道啥是 CRCSN 的讲讲. 总而言之, 这就是我自己开发的一个小项目, 作用是用来破解学校机房里比较主流的控制软件用的. 当初因为一时冲动而成, 目前正在规划 v5.0.0 大更新.&#13;
&#13;
大版本更新, 先画个饼吧. v5.0.0 目前规划的更新如下:&#13;
 - ConsoleUI (伪 GUI)&#13;
 - 重构 '工具箱'&#13;
&#13;
ConsoleUI 是在 Bilibili 上看到一个视频 (详见[此处](https://www.bilibili.com/video/BV1X14y1n7S4/)), 实现了在控制台窗口中使用鼠标点选, 想起 CRCSN 被同学吐槽学习成本高, 他们不会用 ~(我也是真的醉了)~, 才有次立项. 目前打算通过~复制粘贴别人写好的~函数调用 Windows API 实现.&#13;
&#13;
至于重构 '工具箱'...怎么说呢, '工具箱' 这东西从 v4.0.0 添加以来, 使用的人几乎没有, 但大部分的 Bug 却都是这东西的问题...于是折腾了好几个版本后, 忍无可忍才在 v4.9.0 移除. 目前还能再程序内看见它, 但已经被我删的只剩个空壳了. 也算是把那些屎山代码移除了.&#13;
&#13;
v5.0.0 的开发分支预计于 2024 年 6 月 26 日 17:00 左右同步至 GitHub 仓库, 还请各位拭目以待!&#13;
&#13;
GitHub 仓库请点[此处](https://github.com/MaxLHy0424/CRCSN)访问.。</description><guid isPermaLink="true">https://MaxLHy0424.github.io/post/6.html</guid><pubDate>Tue, 25 Jun 2024 08:06:09 +0000</pubDate></item><item><title>为 Hyper-V 中的 Arch Linux 启用增强会话</title><link>https://MaxLHy0424.github.io/post/5.html</link><description>使用 Hyper-V 去安装 GNU/Linux 发行版, 启用增强会话最令人头大. 不清楚是不是 Microsoft 有意为之让大家用 WSL 2. 但总归, 这并不容易.

本教程将教您如何为 Hyper-V 中的 Arch Linux 虚拟机启用增强会话.

# 0 准备工作

&gt; [!IMPORTANT]
&gt; 请确保您的 Arch Linux 虚拟机是第二代虚拟机, 同时使用 pipewire 作声音服务. 并且在 Hyper-V 设置中允许使用增强会话.

然后, 在主机 Windows OS 下以管理员权限打开 PowerShell, 执行 (`&lt;VM&gt;` 改成 Arch Linux 虚拟机的名字, 最好加上英文半角双引号):

```powershell
Set-VM -VMName &lt;VM&gt; -EnhancedSessionTransportType HvSocket
```

# 1 配置包管理器

详见[这篇教程](https://maxlhy0424.github.io/post/2.html)的第 3 部分和[另一篇教程](https://maxlhy0424.github.io/post/10.html).

# 2 安装集成服务

执行以下命令:

```bash
sudo pacman -S hyperv
for i in {vss,fcopy,kvp}; do sudo systemctl enable hv_${i}_daemon.service; done
```

# 3 安装软件包

如果没有安装 git, 请先执行以下命令:

```bash
sudo pacman -S git base-devel
```

执行以下命令:

```bash
git clone https://github.com/microsoft/linux-vm-tools.git
git clone https://aur.archlinux.org/xrdp-devel-git.git
```

首先切换到文件夹 `xrdp-devel-git`, 在文件 `PKGBUILD` 中的 `build()` 部分中, 添加以下参数到构建选项中:

```
--enable-vsock
```

即整个`build()`变为:

```
build() {
  cd $pkgname
  ./configure --prefix=/usr \
              --sysconfdir=/etc \
              --localstatedir=/var \
              --sbindir=/usr/bin \
	      --libexecdir=/usr/lib \
              --with-systemdsystemdunitdir=/usr/lib/systemd/system \
              --enable-jpeg \
              --enable-tjpeg \
              --enable-fuse \
	      --enable-opus \
	      --enable-rfxcodec \
	      --enable-mp3lame \
	      --enable-pixman \
              --enable-vsock
  # Fight unused direct deps
  sed -i -e 's/ -shared / -Wl,-O1,--as-needed\0 /g' -e 's/    if test '$export_dynamic' = yes &amp;&amp; test -n '$export_dynamic_flag_spec'; then/      func_append compile_command ' -Wl,-O1,--as-needed'\n      func_append finalize_command ' -Wl,-O1,--as-needed'\n\0/' libtool
  make V=0
}
```

就是 `# Fight unused direct deps` 上面的两行改了一下.

编辑完成后, 执行命令:

```
makepkg --skipchecksum -si
```

然后执行以下命令:

```
paru -S xorg-xinit xorgxrdp-devel-git openssl-1.1 pipewire-module-xrdp
```

接着切换回当初克隆仓库时所在的目录, 切换到 `linux-vm-tools/arch`, 执行:

```bash
sudo ./install-config.sh
```

&gt; [!WARNING]
&gt; 不要使用 `linux-vm-tools/arch` 中的 `makepkg.sh` 脚本, 其编译选项并不正确.

# 4 解决 XRDP 反复连接问题

在当前用户的家目录下创建 `.xinitrc`.

根据不同的桌面环境添加内容:
 - i3w / dwm:

 ``` 
 exec i3w
 ```

 - Gnome:

 ```
 unset SESSION_MANAGER
 unset DBUS_SESSION_BUS_ADDRESS
 exec dbus-launch  gnome-shell --x11
 ```

 - KDE Plasma:

 ```
 export DESKTOP_SESSION=plasma
 exec startplasma-x11
 ```

 - Xfce4:

 ```
 unset SESSION_MANAGER
 unset DBUS_SESSION_BUS_ADDRESS
 exec dbus-launch startxfce4
 ```

然后执行:

```bash
sudo systemctl enable xrdp.service
sudo systemctl enable xrdp-sesman.service
sudo xrdp-keygen xrdp /etc/xrdp/rsakeys.ini
sudo pacman -Rcns $(pacman -Qtdq)
```

接着重启虚拟机.

重启后依次输入用户名, 用户密码登录账户, 然后在弹出窗口中再次输入账户密码即可.

&gt; [!TIP]
&gt; 实际上直接关闭弹出的窗口也是可以正常使用的, 不过最好还是输入一下账户密码.

至此, 一切大功告成!

# Extra 汉化 SDDM

这一部分和本篇教程没什么关系, 了解下就可以.

如果是以 Systemd 启动 SDDM, 可以打开 `/usr/lib/systemd/system/sddm.service`, 在 `[Service]` 下添加:

```
Environment=LANG=zh_CN.UTF-8
```

如果不是 Systemd 启动, 只能改 `/etc/locale.conf` 了 (不建议改, 虚拟终端会乱码).
。</description><guid isPermaLink="true">https://MaxLHy0424.github.io/post/5.html</guid><pubDate>Mon, 24 Jun 2024 08:44:46 +0000</pubDate></item><item><title>终究是小学毕业了</title><link>https://MaxLHy0424.github.io/post/4.html</link><description>&gt; 本文原定于今天下午 7 点发布, 但因为突然有事, 延迟到了现在, 深感抱歉.&#13;
&#13;
不知不觉间, 小学六年时光匆匆而去. 今天起, 我已不再是一名小学生. 鲜艳的红领巾摆放在柜子的一角, 校徽随手丢在抽屉的深处, 校服消沉在了衣柜中. 以往朝夕相处的同学, 现在只存于照片里了. 小学六年, 每一次的欢乐, 哭泣, 振作, 都沉入了昨日的夕阳. 小学生活, 至此告一段落, 画上了圆满的句号.&#13;
&#13;
六年, 9600 节课, 240 个星期, 12 个学期, 一张试卷考散了一群人, 最后只留下一张照片和一声再见. 六年, 书齐了, 人却散了, 和朝夕相处的同学们坐到站了, 也该下车了...下车后，新的列车依旧坐满了人, 可惜, 已经不是原来那群人了...&#13;
&#13;
还记得那每天两声 '老师好' 和 '老师再见', 到现在, 只剩 '有缘再见'. 时光匆匆中, 每个鲜活的人使我难忘. 我的同学, 我的老师, 现在他们都沉于我的漫漫的记忆长河中了. 那些快乐的时光, 都将在我内心深处如宝石般闪闪发光. 明明已是黑夜, 但我仍可见昨日的夕阳...&#13;
&#13;
我将永远铭记这一切, 直到永远...&#13;
&#13;
我的故事尚未画下句号, 大家的故事尚未画下句号. 你我的故事, 仍需继续写下去, 直到人生终末的句号. 这样的时刻会在不久的将来重演, 而你我, 仍然走着自己的人生之路. 我们回首夕阳, 更要看向远方, 将我们的 '青春剧' 继续演下去...&#13;
&#13;
&gt; 谨以此文献给我亲爱的同学, 老师, 以及我的母校. 愿我们都能书写出自己人生的辉煌篇章.。</description><guid isPermaLink="true">https://MaxLHy0424.github.io/post/4.html</guid><pubDate>Sat, 22 Jun 2024 13:53:41 +0000</pubDate></item><item><title>手把手教您编译适用于 WSL 2 的 Linux Kernel</title><link>https://MaxLHy0424.github.io/post/3.html</link><description>WSL 2 即使更新到最新预发布版本, Linux Kernel 版本也是`6.6.xxx`. 一部分软件可能会需要更高的内核版本, 或者是用户想要测试最新的 Linux Kernel 特性. 因此, 网上替换 WSL 2 的 Linux Kernel 的教程才会如此涌现.

&gt; [!CAUTION]
&gt; 这可能会导致部分 GNU/Linux 发行版不稳定, 软件无法运行等问题. 所以不建议在生产环境中替换 WSL 2 的 Linux Kernel.

&gt; [!TIP]
&gt; 如果您在 WSL 2 中使用 Arch Linux, 建议先阅读[这篇教程](https://MaxLHy0424.github.io/post/2.html), 对 Arch WSL 进行基本的配置, 然后再阅读本教程.

# 1 安装依赖

Debian 系:

```bash
sudo apt install build-essential flex bison dwarves libssl-dev libelf-dev
```

Arch 系:

```bash
sudo pacman -S base-devel flex bison pahole openssl libelf bc
```

# 2 下载 Linux Kernel 源代码

访问 [The Linux Kernel Archive](https://kernel.org), 等待加载完成后, 可以看到网页中间的 Linux Kernel 源代码存档列表. 在此之前, 我们需要了解 Linux Kernel 的主要开发分支:

- `mainline` (主线)
    - Linux Kernel 的主要开发分支, 由 ***Linus Torvalds*** 管理, 包含最新的 Linux Kernel 特性及漏洞修复.
    - 常常作为下一个 Linux Kernel 的开发分支, 可能存在一些稳定性问题.
- `stable` (稳定)
    - 最常用的 Linux Kernel 分支, 包含最新的漏洞修复, 日常使用首选.
- `longterm` (长期)
    - 较旧的 Linux Kernel 分支, 持续进行漏洞修复, 长期使用首选.

根据具体需求下载对应的 Linux Kernel, 然后通过 Windows 资源管理器复制到前面安装好依赖的 GNU/Linux 发行版的用户家目录中.

然后执行以下命令 (将 `&lt;File&gt;` 替换为您的 Linux Kernel 压缩包文件名, 将 `&lt;Dir&gt;` 替换为您的 Linux Kernel 压缩包解压后的目录名):

```bash
cd ~
tar xf &lt;File&gt;
cd &lt;Dir&gt;
```

# 3 编译内核

&gt; [!NOTE]
&gt; 如果您在中国大陆, 此步骤可能需要使用网络代理.

执行以下命令下载适用于 WSL 2 的 Linux Kernel 构建配置并保存:

```bash
wget https://raw.githubusercontent.com/microsoft/WSL2-Linux-Kernel/linux-msft-wsl-6.1.y/arch/x86/configs/config-wsl -O arch/x86/configs/config-wsl
```

然后执行以下命令来使用全部线程编译内核:

```bash
make KCONFIG_CONFIG=arch/x86/configs/config-wsl -j$(nproc)
```

途中的编译配置选择一路按回车即可.

# 4 保存并替换

执行以下命令 (将 `&lt;PATH&gt;` 替换为 C 盘下的文件路径, 例如 `Data/WslLinuxKernel`):

```bash
cp arch/x86/boot/bzImage /mnt/c/&lt;PATH&gt;
```

然后将文件名改为 `kernel`.

接着, 在当前 Windows 用户目录下创建文件 `.wslconfig` (有则不用), 添加 (`[wsl2]` 无需重复添加; 将 `C:\\&lt;PATH&gt;\\kernel` 替换为您的 Linux Kernel 文件路径; 把路径分隔符替换为`\\`):

```
[wsl2]
kernel=C:\\&lt;PATH&gt;\\kernel 
```

接着, 在 Windows Terminal 中执行以下命令:

```Batch
wsl --shutdown
```

再次启动 WSL 2 中的 GNU/Linux 发行版, 执行:

```bash
uname -a
```

Linux Kernel 已经成功替换, 一切大功告成!
。</description><guid isPermaLink="true">https://MaxLHy0424.github.io/post/3.html</guid><pubDate>Fri, 21 Jun 2024 10:43:20 +0000</pubDate></item><item><title>下江小春都能看懂的 Arch WSL 安装与配置指南</title><link>https://MaxLHy0424.github.io/post/2.html</link><description>在 Windows OS 上开发 GNU/Linux 软件时, WSL 2 常为不二之选.

但是, WSL 2 上开箱即用的 GNU/Linux 发行版, 几乎只有 Ubuntu. 想要在 WSL 2 上使用 Arch Linux, 配置较为麻烦.

本教程将帮助您在 WSL 2 上安装并配置 Arch Linux.

&gt; [!NOTE]
&gt; 如果您觉得手动操作有些麻烦, 可以试试博主写的[自动配置脚本](https://gist.github.com/MaxLHy0424/4254cfd932485a93b3b0b73274858bc9). 但还是建议看看教程.

&gt; [!IMPORTANT]
&gt; 适用于 Windows 11 22H2 及以上版本, 其以下的版本可能会出现各种问题.

# 0 准备工作

WSL 2 的硬件需求及启用方法在此处不多赘述, 请自行查阅.

&gt; [!NOTE]
&gt; 如果您有安装 VMware Workstation Pro 等寄居型虚拟机, 推荐改用 Microsoft Hyper-V. 否则其运行的虚拟机性能可能会受到影响.

启用后, 在 Windows Terminal (管理员权限) 中执行以下命令:

```Batch
wsl --update
wsl --update --pre-release
```

接着, 在当前的 Windows OS 用户目录下创建文件`.wslconfig`, 在文件中添加以下内容:

```
[wsl2]
ipv6=true
networkingMode=mirrored
dnsTunneling=true
firewall=true
autoProxy=true
defaultVhdSize=137438953472
[experimental]
autoMemoryReclaim=gradual
bestEffortDnsParsing=true
useWindowsDnsCache=true
```

然后, 在 Microsoft Store 中搜索 `Arch WSL`, 点击下图中所示的软件 (一般为第1个):

![Microsoft Store 搜索结果的局部截图](https://github.com/MaxLHy0424/MaxLHy0424.github.io/assets/142279449/ef60802e-5e57-4b6f-81cf-aa6add640178)

按照正常流程安装, 打开, 创建账户. 

# 1 修改 root 用户密码

通过 `sudo passwd root` 修改`root` 用户密码.

# 2 配置 GNU Nano 文本编辑器

打开 `/etc/nanorc`, 在末尾追加:

```
bind ^X cut main
bind ^C copy main
bind ^V paste all
bind ^Q exit all
bind ^S savefile main
bind ^W writeout main
bind ^O insert main
bind ^H help all
bind ^H exit help
bind ^F whereis all
bind ^G findnext all
bind ^B wherewas all
bind ^D findprevious all
bind ^R replace main
unbind ^U all
unbind ^N main
unbind ^Y all
unbind M-J main
unbind M-T main
bind ^A mark main
bind ^P location main
bind ^T gotoline main
bind ^T gotodir browser
bind ^T cutrestoffile execute
bind ^L linter execute
bind ^E execute main
bind ^K '{mark}{end}{zap}' main
bind ^U '{mark}{home}{zap}' main
bind ^Z undo main
bind ^Y redo main
set tabsize 4
set autoindent
set noconvert
set smarthome
set tabstospaces
set mouse
set linenumbers
set casesensitive
set multibuffer
set nonewlines
set magic
set softwrap
set wordbounds
set constantshow
include /usr/share/nano/*.*
```

# 3 配置包管理器

打开 `/etc/pacman.d/mirrorlist`, 在顶部添加:

```
Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch
```

打开 `/etc/pacman.conf`, 找到:

```
#UseSyslog
#Color
NoProgressBar
```

换成:

```
UseSyslog
Color
#NoProgressBar
```

然后找到这一行:

```
ParallelDownloads = 5
```

将后面的 `5` 修改成你想要同时下载的软件包的数量.

接着把后面的软件源全部删掉, 换成下面的:

```
[testing]
Include = /etc/pacman.d/mirrorlist
[staging]
Include = /etc/pacman.d/mirrorlist
[core-testing]
Include = /etc/pacman.d/mirrorlist
[core-staging]
Include = /etc/pacman.d/mirrorlist
[core]
Include = /etc/pacman.d/mirrorlist
[extra-testing]
Include = /etc/pacman.d/mirrorlist
[extra-staging]
Include = /etc/pacman.d/mirrorlist
[extra]
Include = /etc/pacman.d/mirrorlist
[community-testing]
Include = /etc/pacman.d/mirrorlist
[community-staging]
Include = /etc/pacman.d/mirrorlist
[community]
Include = /etc/pacman.d/mirrorlist
[multilib-testing]
Include = /etc/pacman.d/mirrorlist
[multilib-staging]
Include = /etc/pacman.d/mirrorlist
[multilib]
Include = /etc/pacman.d/mirrorlist
[archlinuxcn]
Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch
[blackarch]
SigLevel = Never
Server = https://mirrors.tuna.tsinghua.edu.cn/blackarch/$repo/os/$arch
```

执行以命令:

```bash
sudo pacman-key --init
sudo pacman-key --lsign-key 'farseerfc@archlinux.org'
sudo pacman -Sy archlinuxcn-keyring blackarch-keyring --noconfirm
```

执行以下命令安装 yay 稳定版 (安装开发版把 `yay` 改为 `yay-git`):

````bash
sudo pacman -S yay
````

如果您愿意的话, 也可以试试 paru, 可以参考[这篇教程](https://maxlhy0424.github.io/post/10.html).

# 4 汉化

打开`/etc/locale.gen`, 找到:

```
#en_US.UTF-8 UTF-8
```

```
#zh_CN.UTF-8 UTF-8
```

将前面的`#`去掉.

打开`/etc/locale.conf`, 将所有文本替换为:

```
LANG=en_US.UTF-8
```

打开`/etc/profile`, 在末尾追加:

```
export LC_ALL=zh_CN.UTF-8
export LANG=zh_CN.UTF-8
export LANGUAGE=zh_CN:en_US
```

然后执行以下命令:

```bash
sudo pacman -S adobe-source-han-sans-cn-fonts adobe-source-han-serif-cn-fonts wqy-microhei wqy-microhei-lite ttf-hannom wqy-zenhei wqy-bitmapfont ttf-arphic-ukai ttf-arphic-uming ttf-hannom noto-fonts opendesktop-fonts noto-fonts-emoji --noconfirm
sudo locale-gen
```

# 5 解决 WSLg 及 Systemd 问题

执行:

```bash
echo '# Type Path           Mode UID  GID  Age Argument
L+     /tmp/.X11-unix -    -    -    -   /mnt/wslg/.X11-unix' | sudo tee /etc/tmpfiles.d/wslg.conf
```

如果 Systemd 没有启动, 可以试试:

```
echo '[boot]
systemd=true' | sudo tee /etc/wsl.conf
```

# 6 善后工作及后续使用注意事项

执行以下命令:

```bash
sudo pacman -Syyu base base-devel git zip unzip net-tools tree python wget btop fastfetch --needed --noconfirm
sudo pacman -Rcns $(pacman -Qtdq) --noconfirm
sudo pacman -Scc --noconfirm
sudo rm -rf /tmp/*
for i in {font,ICE,X11,XIM}; do sudo rm -rf /tmp/.${i}-unix; done
for i in {cache,log,tmp}; do sudo rm -rf /var/${i}/*; done
```

&gt; [!IMPORTANT]
&gt; 如果后续安装软件包缺少依赖, 可以临时注释掉`/etc/pacman.conf`中所有后缀为`testing`或`staging`的软件源, 完成后使用`sudo pacman -Syyu`更新依赖即可.
。</description><guid isPermaLink="true">https://MaxLHy0424.github.io/post/2.html</guid><pubDate>Thu, 20 Jun 2024 11:15:36 +0000</pubDate></item><item><title>关于</title><link>https://MaxLHy0424.github.io/about.html</link><description>欢迎来到我 MaxLHy0424 的 Blog 🤗.

这里会发布**我整理的一些资源**, 和**我自己写的文章** (包括但不限于**教程**, **同人文**).

感兴趣的话, 可以将本网站加入浏览器收藏夹, 或者推荐给其他人. 有 GitHub 账户的话, 就评论下吧, 让 Blog 热闹些也不错 😉.

至于我? 在此介绍下, 目前我是七年级学生 ~(不是 24 岁)~, 2024 年下半年正式成为一名 *OIer* 😎. 会用 **C++** 和 **Shell** 写点小工具, 平时喜欢折腾 Linux 🧐. 偶尔写写同人文 ~(大半是 R18 🥵)~. 游戏方面, 主玩 **Minecraft** 和 **蔚蓝档案 (国际服)**, 同时也会自己做一些游戏玩 😆.

如果感兴趣, 欢迎加入我的 QQ 群 (群号 702827017).

**我的个人账号**:
 - [Bilibili](https://space.bilibili.com/1678066522)
 - [MineBBS](https://www.minebbs.com/members/maxlhy.88192/)
 - [GitHub](https://github.com/MaxLHy0424)
 - QQ: 1097268127
 - Xbox ID: MaxLHy0424

顺带一提, 此 Blog 基于 [Gmeek](https://github.com/Meekdai/Gmeek), 在这里也推荐看看它的维护者 [Meekdai](https://github.com/Meekdai) 的 [Blog](https://blog.meekdai.com) 😚.。</description><guid isPermaLink="true">https://MaxLHy0424.github.io/about.html</guid><pubDate>Thu, 20 Jun 2024 09:44:09 +0000</pubDate></item><item><title>友情链接</title><link>https://MaxLHy0424.github.io/link.html</link><description>这里收录了一些有趣的网站.

- [**哈基密语加密器**](https://lhlnb.top/hajimi) 新奇的文本编码.
- [**Closure Talk**](https://closuretalk.github.io) Yuzutalk 再续香火, Blue Archive 二创制作不可或缺的工具.
- [**Compiler Explorer**](https://godbolt.org) 在线 C++ 编译器合集, C++ 开发者必备.
- [**cppreference.cn**](https://cppreference.cn) cppreference 原站中文镜像.
- [**CTF Wiki**](https://ctf-wiki.org) 网安竞赛 Wiki.
- [**OI Wiki**](https://oi-wiki.org) 信息学奥林匹克竞赛 Wiki.
- [**Peter267**](https://peter267.github.io) 无限进步.。</description><guid isPermaLink="true">https://MaxLHy0424.github.io/link.html</guid><pubDate>Fri, 29 Aug 2025 13:51:07 +0000</pubDate></item></channel></rss>