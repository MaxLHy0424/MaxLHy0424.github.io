---
import ImageWrapper from "../components/misc/ImageWrapper.astro";
import { siteConfig } from "../config";
import localAnimeList from "../data/anime";
import I18nKey from "../i18n/i18nKey";
import { i18n } from "../i18n/translation";
import MainGridLayout from "../layouts/MainGridLayout.astro";
import fs from "node:fs";
import path from "node:path";
import { widgetManager } from "../utils/widget-manager";
import "../styles/anime.css";

interface RawAnimeItem {
	title?: string;
	cover?: string;
	link?: string;
	status?: string;
	rating?: number | string;
	progress?: number | string;
	totalEpisodes?: number | string;
	description?: string;
	year?: string;
	studio?: string;
	genre?: string[];
}

interface AnimeItem {
	title: string;
	cover: string;
	link: string;
	status: string;
	rating: number;
	progress: number;
	totalEpisodes: number;
	description: string;
	year: string;
	studio: string;
	genre: string[];
}

type AnimeSourceConfig =
	| { type: "local"; data: AnimeItem[] }
	| {
			type: "json";
			filename: string;
			fetchOnDev?: boolean;
			emptyDescription?: string; // ÂèØÈÄâÔºöÁâπÂÆöÊ∫êÁöÑÁ©∫Áä∂ÊÄÅÊèèËø∞
	  };

if (!siteConfig.featurePages.anime) {
	return Astro.redirect("/404/");
}

const hasRightSidebars =
	widgetManager.getComponentsByPosition("top", "right", "desktop").length >
		0 ||
	widgetManager.getComponentsByPosition("sticky", "right", "desktop").length >
		0;

const BANGUMI_USER_ID = siteConfig.bangumi?.userId || "your-user-id";
const BILIBILI_VMID = siteConfig.bilibili?.vmid || "";
const ANIME_MODE = siteConfig.anime?.mode || "bangumi";

const sourceConfigs: Record<string, AnimeSourceConfig> = {
	local: {
		type: "local",
		data: localAnimeList,
	},
	bilibili: {
		type: "json",
		filename: "bilibili-data.json",
		fetchOnDev: siteConfig.bilibili?.fetchOnDev,
		emptyDescription: i18n(I18nKey.animeEmptyBilibili),
	},
	bangumi: {
		type: "json",
		filename: "bangumi-data.json",
		fetchOnDev: siteConfig.bangumi?.fetchOnDev,
		emptyDescription: i18n(I18nKey.animeEmptyBangumi),
	},
	// Á§∫‰æãÔºöÊú™Êù•Êâ©Â±ï MyAnimeList
	// myanimelist: {
	//     type: "json",
	//     filename: "mal-data.json",
	//     fetchOnDev: siteConfig.mal?.fetchOnDev
	// }
};

function loadAnimeData(filename: string): AnimeItem[] {
	const dataPath = path.join(process.cwd(), `src/data/${filename}`);

	if (!fs.existsSync(dataPath)) {
		console.warn(`[Anime] Data file not found: ${dataPath}`);
		return [];
	}

	try {
		const fileContent = fs.readFileSync(dataPath, "utf-8");
		const rawData = JSON.parse(fileContent) as RawAnimeItem[];

		return rawData.map((item) => ({
			title: item.title || "Unknown",
			cover: item.cover || "",
			link: item.link || "",
			status: item.status || "planned",
			rating: Number(item.rating) || 0,
			progress: Number(item.progress) || 0,
			totalEpisodes: Number(item.totalEpisodes) || 12,
			description: item.description || "",
			year: item.year || "",
			studio: item.studio || "",
			genre: Array.isArray(item.genre) ? item.genre : [],
		}));
	} catch (error) {
		console.error(`[Anime] Failed to parse ${filename}:`, error);
		return [];
	}
}

let animeList: AnimeItem[] = [];
const currentConfig = sourceConfigs[ANIME_MODE];

if (currentConfig) {
	if (currentConfig.type === "local") {
		animeList = currentConfig.data;
	} else if (currentConfig.type === "json") {
		const isDev = import.meta.env.DEV;
		const shouldFetchOnDev = currentConfig.fetchOnDev ?? false;
		const skipLoad = isDev && !shouldFetchOnDev;

		if (skipLoad) {
			console.log(
				`[Dev] Skipping ${ANIME_MODE} data load (fetchOnDev is off).`,
			);
			animeList = [];
		} else {
			animeList = loadAnimeData(currentConfig.filename);
		}
	}
} else {
	console.warn(`[Anime] Unknown or unconfigured mode: ${ANIME_MODE}`);
}

let emptyMessage = i18n(I18nKey.animeEmpty);
let emptyDescription = "";
let showEmptyState = false;

if (ANIME_MODE === "bilibili" && (!BILIBILI_VMID || BILIBILI_VMID === "")) {
	showEmptyState = true;
	emptyDescription = i18n(I18nKey.animeConfigBilibili);
} else if (ANIME_MODE === "bangumi" && BANGUMI_USER_ID === "your-user-id") {
	showEmptyState = true;
	emptyDescription = i18n(I18nKey.animeConfigBangumi);
} else if (animeList.length === 0) {
	showEmptyState = true;
	// ‰ºòÂÖà‰ΩøÁî®ÈÖçÁΩÆ‰∏≠ÁöÑÁ©∫ÊèèËø∞ÔºåÂê¶ÂàôÂõûÈÄÄÂà∞ÈªòËÆ§
	if (
		currentConfig &&
		currentConfig.type === "json" &&
		currentConfig.emptyDescription
	) {
		emptyDescription = currentConfig.emptyDescription;
	} else if (ANIME_MODE === "local") {
		emptyDescription = i18n(I18nKey.animeEmptyLocal);
	} else {
		emptyDescription = "No anime data found.";
	}
}

// Áä∂ÊÄÅÊ†∑ÂºèÊò†Â∞Ñ
const statusMap: Record<string, { text: string; class: string; icon: string }> =
	{
		watching: {
			text: i18n(I18nKey.animeStatusWatching),
			class: "bg-green-100 text-green-700 dark:bg-green-900/30 dark:text-green-300",
			icon: "‚ñ∂",
		},
		completed: {
			text: i18n(I18nKey.animeStatusCompleted),
			class: "bg-blue-100 text-blue-700 dark:bg-blue-900/30 dark:text-blue-300",
			icon: "‚úì",
		},
		planned: {
			text: i18n(I18nKey.animeStatusPlanned),
			class: "bg-amber-100 text-amber-700 dark:bg-amber-900/30 dark:text-amber-300",
			icon: "‚ù§",
		},
		onhold: {
			text: i18n(I18nKey.animeStatusOnHold),
			class: "bg-purple-100 text-purple-700 dark:bg-purple-900/30 dark:text-purple-300",
			icon: "‚è∏",
		},
		dropped: {
			text: i18n(I18nKey.animeStatusDropped),
			class: "bg-red-100 text-red-700 dark:bg-red-900/30 dark:text-red-300",
			icon: "‚úó",
		},
	};

function getStatusInfo(status: string) {
	return (
		statusMap[status] || {
			text: status,
			class: "bg-gray-100 text-gray-700 dark:bg-gray-800 dark:text-gray-300",
			icon: "?",
		}
	);
}

const INITIAL_DISPLAY_COUNT = 24;
const visibleAnimeList = animeList.slice(0, INITIAL_DISPLAY_COUNT);
const hiddenAnimeList = animeList.slice(INITIAL_DISPLAY_COUNT);
---

<MainGridLayout
	title={i18n(I18nKey.anime)}
	description={i18n(I18nKey.animeSubtitle)}
>
	<div
		class="flex w-full rounded-(--radius-large) overflow-hidden relative min-h-32"
	>
		<div class="card-base anime-card-base z-10 px-9 py-6 relative w-full">
			<div class="relative w-full mb-8">
				<div class="mb-6">
					<h1
						class="text-4xl font-bold text-90 mb-2 relative
                    before:w-1 before:h-8 before:rounded-md before:bg-(--primary)
                    before:absolute before:top-1/2 before:-translate-y-1/2 before:-left-4"
					>
						{i18n(I18nKey.animeTitle)}
					</h1>
					<p class="text-75">
						{i18n(I18nKey.animeSubtitle)}
					</p>
				</div>

				<div class="mb-6">
					<div class="anime-filter-container flex flex-wrap gap-2">
						<button
							class="anime-filter-tag anime-active"
							data-status="all"
							>{i18n(I18nKey.animeFilterAll)}</button
						>
						<button class="anime-filter-tag" data-status="watching"
							>{i18n(I18nKey.animeStatusWatching)}</button
						>
						<button class="anime-filter-tag" data-status="planned"
							>{i18n(I18nKey.animeStatusPlanned)}</button
						>
						<button class="anime-filter-tag" data-status="completed"
							>{i18n(I18nKey.animeStatusCompleted)}</button
						>
						{
							ANIME_MODE === "bangumi" && (
								<>
									<button
										class="anime-filter-tag"
										data-status="onhold"
									>
										{i18n(I18nKey.animeStatusOnHold)}
									</button>
									<button
										class="anime-filter-tag"
										data-status="dropped"
									>
										{i18n(I18nKey.animeStatusDropped)}
									</button>
								</>
							)
						}
					</div>
				</div>
			</div>

			<div class="mb-8">
				{
					showEmptyState ? (
						<div class="text-center py-12">
							<div class="text-5xl mb-4">üò¢</div>
							<h3 class="text-xl font-medium text-90 mb-2">
								{emptyMessage}
							</h3>
							<p class="text-60">
								{emptyDescription}
							</p>
						</div>
					) : (
						<>
							<div
								id="anime-list-container"
								class={`anime-grid-container grid gap-4 md:gap-6 opacity-0 transition-opacity duration-300`}
							>
								{visibleAnimeList.map((anime) => {
									const statusInfo = getStatusInfo(
										anime.status,
									);
									const progressPercent =
										anime.totalEpisodes > 0
											? (anime.progress /
													anime.totalEpisodes) *
												100
											: 0;

									return (
										<div
											class="group relative bg-(--card-bg) border border-(--line-divider) rounded-(--radius-large) overflow-hidden hover:shadow-lg"
											data-anime-status={anime.status}
										>
											<div class="relative anime-cover-container aspect-2/3 overflow-hidden">
												<a
													href={anime.link}
													target="_blank"
													rel="noopener noreferrer"
													class="block w-full h-full"
												>
													<ImageWrapper
														src={anime.cover}
														alt={anime.title}
														class="w-full h-full object-cover transition-transform duration-200 group-hover:scale-110"
													/>
													<div class="absolute inset-0 bg-linear-to-t from-black/60 via-transparent to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-300">
														<div class="absolute inset-0 flex items-center justify-center">
															<div class="w-12 h-12 rounded-full bg-white/90 flex items-center justify-center">
																<svg
																	class="w-6 h-6 text-gray-800 ml-1"
																	fill="currentColor"
																	viewBox="0 0 24 24"
																>
																	<path d="M8 5v14l11-7z" />
																</svg>
															</div>
														</div>
													</div>
												</a>

												<div
													class={`absolute top-2 left-2 px-2 py-1 rounded-md text-xs font-medium ${statusInfo.class}`}
												>
													<span class="mr-1">
														{statusInfo.icon}
													</span>
													<span>
														{statusInfo.text}
													</span>
												</div>

												<div class="absolute top-2 right-2 bg-black/70 text-white px-2 py-1 rounded-md text-xs font-medium flex items-center gap-1">
													<svg
														class="w-3 h-3 text-yellow-400"
														fill="currentColor"
														viewBox="0 0 20 20"
													>
														<path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" />
													</svg>
													<span>{anime.rating}</span>
												</div>

												{anime.status ===
													"watching" && (
													<div class="absolute bottom-0 left-0 right-0 bg-linear-to-t from-black/80 to-transparent p-2">
														<div class="w-full bg-white/20 rounded-full h-1.5 mb-1">
															<div
																class="bg-linear-to-r from-emerald-400 to-teal-400 h-1.5 rounded-full transition-all duration-300"
																style={`width: ${progressPercent}%`}
															/>
														</div>
														<div class="text-white text-xs font-medium">
															{anime.progress}/
															{
																anime.totalEpisodes
															}{" "}
															(
															{Math.round(
																progressPercent,
															)}
															%)
														</div>
													</div>
												)}
											</div>

											<div class="p-3">
												<h3 class="text-sm font-bold text-90 mb-1 leading-tight">
													{anime.title}
												</h3>
												<p
													class="text-60 text-xs mb-2 line-clamp-2"
													title={anime.description}
												>
													{anime.description}
												</p>

												<div class="space-y-1 text-xs">
													<div class="flex justify-between items-center">
														<span class="text-50 shrink-0">
															{i18n(
																I18nKey.animeYear,
															)}
														</span>
														<span class="text-70 truncate ml-2 text-right">
															{anime.year}
														</span>
													</div>
													<div class="flex justify-between items-start">
														<span class="text-50 shrink-0 mt-0.5">
															{i18n(
																I18nKey.animeStudio,
															)}
														</span>
														<span
															class="text-70 text-right ml-2 line-clamp-2 wrap-break-word"
															title={anime.studio}
														>
															{anime.studio}
														</span>
													</div>
													<div class="flex flex-wrap gap-1 mt-2">
														{anime.genre.map(
															(g) => (
																<span class="px-1.5 py-0.5 bg-(--btn-regular-bg) text-70 rounded text-xs">
																	{g}
																</span>
															),
														)}
													</div>
												</div>
											</div>
										</div>
									);
								})}
							</div>

							<template id="anime-lazy-store">
								{hiddenAnimeList.map((anime) => {
									const statusInfo = getStatusInfo(
										anime.status,
									);
									const progressPercent =
										anime.totalEpisodes > 0
											? (anime.progress /
													anime.totalEpisodes) *
												100
											: 0;

									return (
										<div
											class="group relative bg-(--card-bg) border border-(--line-divider) rounded-(--radius-large) overflow-hidden hover:shadow-lg"
											data-anime-status={anime.status}
										>
											<div class="relative anime-cover-container aspect-2/3 overflow-hidden">
												<a
													href={anime.link}
													target="_blank"
													rel="noopener noreferrer"
													class="block w-full h-full"
												>
													<ImageWrapper
														src={anime.cover}
														alt={anime.title}
														class="w-full h-full object-cover transition-transform duration-200 group-hover:scale-110"
													/>
													<div class="absolute inset-0 bg-linear-to-t from-black/60 via-transparent to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-300">
														<div class="absolute inset-0 flex items-center justify-center">
															<div class="w-12 h-12 rounded-full bg-white/90 flex items-center justify-center">
																<svg
																	class="w-6 h-6 text-gray-800 ml-1"
																	fill="currentColor"
																	viewBox="0 0 24 24"
																>
																	<path d="M8 5v14l11-7z" />
																</svg>
															</div>
														</div>
													</div>
												</a>

												<div
													class={`absolute top-2 left-2 px-2 py-1 rounded-md text-xs font-medium ${statusInfo.class}`}
												>
													<span class="mr-1">
														{statusInfo.icon}
													</span>
													<span>
														{statusInfo.text}
													</span>
												</div>

												<div class="absolute top-2 right-2 bg-black/70 text-white px-2 py-1 rounded-md text-xs font-medium flex items-center gap-1">
													<svg
														class="w-3 h-3 text-yellow-400"
														fill="currentColor"
														viewBox="0 0 20 20"
													>
														<path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" />
													</svg>
													<span>{anime.rating}</span>
												</div>

												{anime.status ===
													"watching" && (
													<div class="absolute bottom-0 left-0 right-0 bg-linear-to-t from-black/80 to-transparent p-2">
														<div class="w-full bg-white/20 rounded-full h-1.5 mb-1">
															<div
																class="bg-linear-to-r from-emerald-400 to-teal-400 h-1.5 rounded-full transition-all duration-300"
																style={`width: ${progressPercent}%`}
															/>
														</div>
														<div class="text-white text-xs font-medium">
															{anime.progress}/
															{
																anime.totalEpisodes
															}{" "}
															(
															{Math.round(
																progressPercent,
															)}
															%)
														</div>
													</div>
												)}
											</div>

											<div class="p-3">
												<h3 class="text-sm font-bold text-90 mb-1 leading-tight">
													{anime.title}
												</h3>
												<p
													class="text-60 text-xs mb-2 line-clamp-2"
													title={anime.description}
												>
													{anime.description}
												</p>

												<div class="space-y-1 text-xs">
													<div class="flex justify-between items-center">
														<span class="text-50 shrink-0">
															{i18n(
																I18nKey.animeYear,
															)}
														</span>
														<span class="text-70 truncate ml-2 text-right">
															{anime.year}
														</span>
													</div>
													<div class="flex justify-between items-start">
														<span class="text-50 shrink-0 mt-0.5">
															{i18n(
																I18nKey.animeStudio,
															)}
														</span>
														<span
															class="text-70 text-right ml-2 line-clamp-2 wrap-break-word"
															title={anime.studio}
														>
															{anime.studio}
														</span>
													</div>
													<div class="flex flex-wrap gap-1 mt-2">
														{anime.genre.map(
															(g) => (
																<span class="px-1.5 py-0.5 bg-(--btn-regular-bg) text-70 rounded text-xs">
																	{g}
																</span>
															),
														)}
													</div>
												</div>
											</div>
										</div>
									);
								})}
							</template>

							{hiddenAnimeList.length > 0 && (
								<div
									id="infinite-scroll-sentinel"
									class="w-full h-20 flex items-center justify-center mt-8"
								>
									<div class="anime-loading-spinner w-8 h-8 border-4 border-(--primary) border-t-transparent rounded-full animate-spin" />
								</div>
							)}
						</>
					)
				}
			</div>
		</div>
	</div>

	<script is:inline define:vars={{ hasRightSidebars }}>
		(function () {
			function initAnimeLayout() {
				const animeListContainer = document.getElementById(
					"anime-list-container",
				);
				if (!animeListContainer) return false;
				const currentLayout =
					localStorage.getItem("postListLayout") || "list";
				updateAnimeListLayout(currentLayout, false);
				requestAnimationFrame(() => {
					animeListContainer.classList.remove("opacity-0");
				});
				return true;
			}

			let retryCount = 0;
			const maxRetries = 10;
			function tryInit() {
				if (initAnimeLayout()) return;
				if (retryCount < maxRetries) {
					retryCount++;
					const delay = Math.min(
						100 * Math.pow(1.5, retryCount),
						1000,
					);
					setTimeout(tryInit, delay);
				} else {
					setTimeout(() => {
						const animeListContainer = document.getElementById(
							"anime-list-container",
						);
						if (animeListContainer) {
							const currentLayout =
								localStorage.getItem("postListLayout") ||
								"list";
							updateAnimeListLayout(currentLayout, false);
							animeListContainer.classList.remove("opacity-0");
						}
					}, 2000);
				}
			}

			if (document.readyState === "loading") {
				document.addEventListener("DOMContentLoaded", tryInit);
			} else {
				tryInit();
			}

			function updateAnimeListLayout(layout, shouldAnimate = true) {
				const animeListContainer = document.getElementById(
					"anime-list-container",
				);
				if (!animeListContainer) return;
				animeListContainer.dataset.currentLayout = layout;

				const animeItems = Array.from(
					document.querySelectorAll("[data-anime-status]"),
				);
				const visibleItems = animeItems.filter(
					(item) => item.offsetParent !== null,
				);
				const firstPositions = new Map();
				if (shouldAnimate) {
					visibleItems.forEach((item) => {
						const rect = item.getBoundingClientRect();
						firstPositions.set(item, {
							left: rect.left,
							top: rect.top,
							width: rect.width,
							height: rect.height,
						});
					});
				}

				const style = document.createElement("style");
				style.innerHTML = `.anime-grid-container .group { transition: none !important; }`;
				document.head.appendChild(style);
				animeListContainer.classList.remove(
					"anime-list-mode",
					"anime-grid-mode",
				);
				animeListContainer.classList.remove(
					"grid-cols-1",
					"md:grid-cols-2",
					"lg:grid-cols-3",
				);
				if (layout === "grid") {
					animeListContainer.classList.add("anime-grid-mode");
					const rightSidebar = document.querySelector(
						".right-sidebar-container",
					);
					if (rightSidebar) {
						rightSidebar.style.display = "none";
						rightSidebar.classList.add("hidden-in-grid-mode");
					}
					const mainGrid = document.getElementById("main-grid");
					if (mainGrid) {
						mainGrid.style.gridTemplateColumns = "17.5rem 1fr";
						mainGrid.classList.add("two-column-layout");
					}
				} else {
					animeListContainer.classList.add("anime-list-mode");
					animeListContainer.classList.add(
						"grid-cols-1",
						"lg:grid-cols-2",
					);
					const rightSidebar = document.querySelector(
						".right-sidebar-container",
					);
					if (rightSidebar) {
						rightSidebar.style.display = "";
						rightSidebar.classList.remove("hidden-in-grid-mode");
					}
					const mainGrid = document.getElementById("main-grid");
					if (mainGrid) {
						mainGrid.style.gridTemplateColumns = "";
						mainGrid.classList.remove("two-column-layout");
					}
				}

				void animeListContainer.offsetHeight;
				if (!shouldAnimate) {
					if (style.parentNode) style.parentNode.removeChild(style);
					return;
				}

				requestAnimationFrame(() => {
					if (style.parentNode) style.parentNode.removeChild(style);

					visibleItems.forEach((item) => {
						const first = firstPositions.get(item);
						if (!first) return;
						const last = item.getBoundingClientRect();

						const deltaX = Math.round(first.left - last.left);
						const deltaY = Math.round(first.top - last.top);
						const deltaW = first.width / last.width;
						const deltaH = first.height / last.height;

						if (
							Math.abs(deltaX) < 1 &&
							Math.abs(deltaY) < 1 &&
							Math.abs(deltaW - 1) < 0.01 &&
							Math.abs(deltaH - 1) < 0.01
						)
							return;

						item.style.willChange = "transform";
						item.style.transition = "none";
						item.style.transformOrigin = "top left";
						item.style.transform = `translate(${deltaX}px, ${deltaY}px) scale(${deltaW}, ${deltaH})`;
					});

					void animeListContainer.offsetHeight;
					requestAnimationFrame(() => {
						visibleItems.forEach((item) => {
							item.style.transition =
								"transform 0.5s cubic-bezier(0.25, 0.8, 0.25, 1)";
							item.style.transform = "";
						});
						setTimeout(() => {
							visibleItems.forEach((item) => {
								item.style.transition = "";
								item.style.transformOrigin = "";
								item.style.transform = "";
								item.style.willChange = "";
							});
						}, 500);
					});
				});
			}

			window.addEventListener("layoutChange", (event) => {
				updateAnimeListLayout(event.detail.layout);
			});
		})();
	</script>

	<script is:inline>
		if (typeof window.animeFilterEventListeners === "undefined") {
			window.animeFilterEventListeners = [];
		}

		function initFilterButtons() {
			const filterTags = document.querySelectorAll(".anime-filter-tag");
			const sentinel = document.getElementById(
				"infinite-scroll-sentinel",
			);
			const listContainer = document.getElementById(
				"anime-list-container",
			);
			const lazyStore = document.getElementById("anime-lazy-store");
			window.animeFilterEventListeners.forEach((listener) => {
				const [element, type, handler] = listener;
				element.removeEventListener(type, handler);
			});
			window.animeFilterEventListeners = [];
			filterTags.forEach((tag) => {
				const clickHandler = function () {
					if (this.classList.contains("anime-active")) return;

					filterTags.forEach((t) =>
						t.classList.remove("anime-active"),
					);
					this.classList.add("anime-active");

					if (
						lazyStore &&
						lazyStore.content.children.length > 0 &&
						listContainer
					) {
						const fragment = document.createDocumentFragment();
						while (lazyStore.content.firstChild) {
							const node = lazyStore.content.firstChild;
							fragment.appendChild(node);
						}
						listContainer.appendChild(fragment);
					}

					if (sentinel) sentinel.style.display = "none";
					const initialHidden =
						listContainer.querySelectorAll(".initial-hidden");
					initialHidden.forEach((el) => {
						el.classList.remove("hidden", "initial-hidden");
					});

					const status = this.getAttribute("data-status");
					const animeItems = Array.from(
						listContainer.children,
					).filter((item) => item.hasAttribute("data-anime-status"));
					const itemsToHide = [];
					const itemsToShow = [];
					const itemsToKeep = [];
					animeItems.forEach((item) => {
						const itemStatus =
							item.getAttribute("data-anime-status");
						const shouldShow =
							status === "all" || itemStatus === status;
						const isCurrentlyVisible =
							!item.classList.contains("anime-hidden");

						if (shouldShow) {
							isCurrentlyVisible
								? itemsToKeep.push(item)
								: itemsToShow.push(item);
						} else {
							if (isCurrentlyVisible) itemsToHide.push(item);
						}
					});
					const firstPositions = new Map();
					itemsToKeep.forEach((item) => {
						const rect = item.getBoundingClientRect();
						firstPositions.set(item, {
							left: rect.left,
							top: rect.top,
						});
					});
					const runAnimation = () => {
						itemsToHide.forEach((item) => {
							item.classList.add("anime-hidden");
							item.classList.remove("anime-fade-out");
						});
						itemsToShow.forEach((item) => {
							item.classList.remove("anime-hidden");
							item.classList.add("anime-fade-in");
							item.style.transition = "none";
						});
						itemsToKeep.forEach((item) => {
							const first = firstPositions.get(item);
							if (!first) return;

							const rect = item.getBoundingClientRect();
							const deltaX = Math.round(first.left - rect.left);
							const deltaY = Math.round(first.top - rect.top);

							if (deltaX !== 0 || deltaY !== 0) {
								item.style.willChange = "transform";
								item.style.transition = "none";
								item.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
							}
						});
						requestAnimationFrame(() => {
							itemsToKeep.forEach((item) => {
								item.style.transition =
									"transform 0.5s cubic-bezier(0.4, 0, 0.2, 1)";
								item.style.transform = "";
							});

							const STAGGER_LIMIT = 20;
							itemsToShow.forEach((item, index) => {
								item.style.transition = "";
								item.style.willChange = "opacity, transform";

								const delay =
									index < STAGGER_LIMIT ? index * 30 : 0;
								item.style.transitionDelay = `${delay}ms`;

								requestAnimationFrame(() => {
									item.classList.remove("anime-fade-in");
									item.classList.add("anime-fade-in-active");
								});
							});

							setTimeout(
								() => {
									[...itemsToKeep, ...itemsToShow].forEach(
										(item) => {
											item.classList.remove(
												"anime-fade-in-active",
											);
											item.style.transition = "";
											item.style.transform = "";
											item.style.opacity = "";
											item.style.willChange = "";
											item.style.transitionDelay = "";
										},
									);
								},
								600 +
									(itemsToShow.length > 0
										? Math.min(itemsToShow.length, 20) * 30
										: 0),
							);
						});
					};
					if (itemsToHide.length > 0) {
						itemsToHide.forEach((item) =>
							item.classList.add("anime-fade-out"),
						);
						setTimeout(runAnimation, 200);
					} else {
						runAnimation();
					}
				};

				tag.addEventListener("click", clickHandler);
				window.animeFilterEventListeners.push([
					tag,
					"click",
					clickHandler,
				]);
			});
			if (sentinel && lazyStore && listContainer) {
				const observer = new IntersectionObserver(
					(entries) => {
						if (entries[0].isIntersecting) {
							const BATCH_SIZE = 24;
							if (lazyStore.content.children.length === 0) {
								sentinel.style.display = "none";
								observer.disconnect();
								return;
							}

							const fragment = document.createDocumentFragment();
							let movedCount = 0;
							while (
								lazyStore.content.firstChild &&
								movedCount < BATCH_SIZE
							) {
								const node = lazyStore.content.firstChild;
								if (node.nodeType === 1) {
									node.classList.add("anime-fade-in-active");
								}
								fragment.appendChild(node);
								movedCount++;
							}

							requestAnimationFrame(() => {
								listContainer.appendChild(fragment);
								if (lazyStore.content.children.length === 0) {
									sentinel.style.display = "none";
									observer.disconnect();
								}
							});
						}
					},
					{ rootMargin: "200px" },
				);
				observer.observe(sentinel);
			} else if (sentinel) {
				sentinel.style.display = "none";
			}
		}

		document.addEventListener("DOMContentLoaded", initFilterButtons);
		function setupSwupListeners() {
			if (window.swup) {
				window.swup.hooks.on("content:replace", () =>
					setTimeout(initFilterButtons, 150),
				);
				window.swup.hooks.on("page:view", () =>
					setTimeout(initFilterButtons, 150),
				);
			}
		}

		if (typeof window !== "undefined") {
			if (window.swup) {
				setupSwupListeners();
			} else {
				document.addEventListener("swup:enable", setupSwupListeners);
			}
		}
	</script>
</MainGridLayout>
