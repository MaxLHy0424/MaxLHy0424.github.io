---
import I18nKey from "../i18n/i18nKey";
import { i18n } from "../i18n/translation";

export interface Props {
	encryptedContent: string;
}

const { encryptedContent } = Astro.props;
---

<div id="password-protection" class="password-protection">
	<div class="password-container">
		<div class="lock-icon">
			<svg
				width="48"
				height="48"
				viewBox="0 0 24 24"
				fill="none"
				xmlns="http://www.w3.org/2000/svg"
                class="w-12 h-12"
			>
				<path
					d="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zM9 6c0-1.66 1.34-3 3-3s3 1.34 3 3v2H9V6z"
					fill="currentColor"></path>
			</svg>
		</div>
		<h2>{i18n(I18nKey.passwordProtectedTitle)}</h2>
		<p>{i18n(I18nKey.passwordProtectedDescription)}</p>
		<div class="password-input-group">
			<input
				type="password"
				id="password-input"
				placeholder={i18n(I18nKey.passwordPlaceholder)}
				class="password-input"
			/>
			<button id="unlock-btn" class="unlock-button"
				>{i18n(I18nKey.passwordUnlock)}</button
			>
		</div>
		<div id="error-message" class="error-message" style="display: none;">
			{i18n(I18nKey.passwordIncorrect)}
		</div>
	</div>
</div>

<div
	id="decrypted-content"
	class="decrypted-content w-full"
	style="display: none;"
>
</div>

<style>
	.password-protection {
		display: flex;
		justify-content: center;
		align-items: center;
		min-height: 60vh;
		padding: 2rem;
	}

	.password-container {
		text-align: center;
		max-width: 25rem;
		width: 100%;
		padding: 2rem;
		border-radius: 12px;
		background: transparent;
		border: 1px solid var(--line-divider);
		box-shadow: none;
	}

	.lock-icon {
		display: flex;
		justify-content: center;
		margin-bottom: 1rem;
		color: var(--primary);
	}
    
    .lock-icon svg {
        width: 3rem;
        height: 3rem;
    }

	.password-container h2 {
		margin-bottom: 0.5rem;
		color: rgba(0, 0, 0, 0.85);
		font-size: 1.5rem;
	}

	:global(.dark) .password-container h2 {
		color: rgba(255, 255, 255, 0.85);
	}

	.password-container p {
		margin-bottom: 1.5rem;
		color: rgba(0, 0, 0, 0.75);
		opacity: 0.8;
	}

	:global(.dark) .password-container p {
		color: rgba(255, 255, 255, 0.75);
	}

	.password-input-group {
		display: flex;
		gap: 0.5rem;
		margin-bottom: 1rem;
		align-items: stretch;
	}

	.password-input {
		flex: 1;
		min-width: 0;
		padding: 0.75rem 1rem;
		border: 1px solid var(--line-divider);
		border-radius: 8px;
		background: transparent;
		color: rgba(0, 0, 0, 0.85);
		font-size: 1rem;
		transition: border-color 0.2s ease;
	}

	:global(.dark) .password-input {
		color: rgba(255, 255, 255, 0.85);
	}

	.password-input::placeholder {
		color: rgba(0, 0, 0, 0.5);
	}

	:global(.dark) .password-input::placeholder {
		color: rgba(255, 255, 255, 0.5);
	}

	.password-input:focus {
		outline: none;
		border-color: var(--primary);
	}

	.unlock-button {
		padding: 0.75rem 1.5rem;
		background: transparent;
		color: var(--primary);
		border: 1px solid var(--primary);
		border-radius: 8px;
		font-size: 1rem;
		cursor: pointer;
		transition:
			border-color 0.2s,
			color 0.2s,
			background 0.2s;
		white-space: nowrap;
		flex-shrink: 0;
		min-width: fit-content;
		max-width: max-content;
	}

	.unlock-button:hover {
		background: var(--primary);
		color: white;
		border-color: var(--primary);
	}

	.unlock-button:disabled {
		opacity: 0.6;
		cursor: not-allowed;
	}

	.error-message {
		color: #ef4444;
		font-size: 0.875rem;
		margin-top: 0.5rem;
	}

	.decrypted-content {
		animation: fadeIn 0.3s ease-in-out;
	}

	@keyframes fadeIn {
		from {
			opacity: 0;
			transform: translateY(10px);
		}
		to {
			opacity: 1;
			transform: translateY(0);
		}
	}

	:global(#decrypted-content .table-wrapper) {
		overflow-x: auto !important;
		width: 100% !important;
	}

	:global(#decrypted-content table) {
		display: table !important;
		width: 100% !important;
	}

	/* Hide encrypted components initially */
	:global(.encrypted-hidden) {
		display: none !important;
	}

	:global(.encrypted-hidden-wrapper.encrypted-hidden) {
		display: none !important;
	}

	@media (min-width: 769px) {
		.password-input-group {
			flex-wrap: nowrap;
		}

		.unlock-button {
			max-width: 40%;
		}
	}

	/* 移动端适配 */
	@media (max-width: 768px) {
		.password-protection {
			padding: 1rem;
			min-height: 50vh;
		}

		.password-container {
			max-width: none;
			width: 100%;
			padding: 1.5rem;
			margin: 0 0.5rem;
		}

		.password-container h2 {
			font-size: 1.25rem;
			margin-bottom: 0.75rem;
		}

		.password-container p {
			font-size: 0.9rem;
			margin-bottom: 1.25rem;
		}

		.password-input-group {
			flex-direction: column;
			gap: 0.75rem;
		}

		.password-input {
			padding: 0.875rem 1rem;
			font-size: 1rem;
			width: 100%;
		}

		.unlock-button {
			padding: 0.875rem 1rem;
			font-size: 1rem;
			max-width: 100%;
			width: 100%;
			white-space: nowrap;
		}

		.error-message {
			font-size: 0.8rem;
			text-align: center;
		}
	}

	/* 小屏手机适配 */
	@media (max-width: 480px) {
		.password-protection {
			padding: 0.75rem;
		}

		.password-container {
			padding: 1.25rem;
			margin: 0 0.25rem;
		}

		.password-container h2 {
			font-size: 1.125rem;
		}

		.password-container p {
			font-size: 0.85rem;
		}

		.password-input {
			padding: 0.75rem 0.875rem;
			font-size: 0.95rem;
		}

		.unlock-button {
			padding: 0.75rem 0.875rem;
			font-size: 0.95rem;
		}
	}
</style>

<script
	is:inline
	define:vars={{
		encryptedContent,
		i18nUnlocking: i18n(I18nKey.passwordUnlocking),
		i18nIncorrect: i18n(I18nKey.passwordIncorrect),
		i18nDecryptError: i18n(I18nKey.passwordDecryptError),
		i18nUnlock: i18n(I18nKey.passwordUnlock),
		i18nCopyFailed: i18n(I18nKey.copyFailed),
		i18nPasswordRequired: i18n(I18nKey.passwordRequired),
		i18nDecryptionError: i18n(I18nKey.decryptionError),
		i18nPasswordDecryptRetry: i18n(I18nKey.passwordDecryptRetry),
	}}
>
	async function loadCryptoLibraries() {
		if (typeof CryptoJS === "undefined") {
			await new Promise((resolve, reject) => {
				const script = document.createElement("script");
				script.src = "/assets/js/crypto-js.min.js";
				script.onload = resolve;
				script.onerror = reject;
				document.head.appendChild(script);
			});
		}
	}

	async function initPasswordProtection() {
		const savedPassword = sessionStorage.getItem(
			"page-password-" + window.location.pathname,
		);
		const protectionDiv = document.getElementById("password-protection");
		if (savedPassword && protectionDiv) {
			const inputGroup = protectionDiv.querySelector(
				".password-input-group",
			);
			if (inputGroup) {
				inputGroup.style.visibility = "hidden";
			}
			const hint = protectionDiv.querySelector(".password-container p");
			if (hint) {
				hint.setAttribute("data-original-text", hint.textContent);
				hint.textContent = i18nUnlocking;
			}
			protectionDiv.classList.add("auto-unlocking");
		}

		await loadCryptoLibraries();

		const passwordInput = document.getElementById("password-input");
		const unlockBtn = document.getElementById("unlock-btn");
		const errorMessage = document.getElementById("error-message");
		const contentDiv = document.getElementById("decrypted-content");

		async function attemptUnlock() {
			const inputPassword = passwordInput.value.trim() || savedPassword;

			if (!inputPassword) {
				showError(i18nPasswordRequired);
				return;
			}

			unlockBtn.disabled = true;
			unlockBtn.textContent = i18nUnlocking;
			errorMessage.style.display = "none";

			try {
				const decryptedBytes = CryptoJS.AES.decrypt(
					encryptedContent,
					inputPassword,
				);
				const decryptedString = decryptedBytes.toString(
					CryptoJS.enc.Utf8,
				);

				if (
					!decryptedString ||
					!decryptedString.startsWith("MIZUKI-VERIFY:")
				) {
					showError(i18nIncorrect);
					if (savedPassword) {
						sessionStorage.removeItem(
							"page-password-" + window.location.pathname,
						);
						const inputGroup = protectionDiv.querySelector(
							".password-input-group",
						);
						if (inputGroup) {
							inputGroup.style.visibility = "visible";
						}
						const hint = protectionDiv.querySelector(
							".password-container p",
						);
						if (hint && hint.hasAttribute("data-original-text")) {
							hint.textContent =
								hint.getAttribute("data-original-text");
						}
						passwordInput.value = "";
						protectionDiv.classList.remove("auto-unlocking");
					}
					return;
				}

				const realContent = decryptedString.replace(
					"MIZUKI-VERIFY:",
					"",
				);

				contentDiv.innerHTML = realContent;

				// 手动执行解密后的 script 标签
				const scripts = contentDiv.querySelectorAll("script");
				const scriptPromises = Array.from(scripts).map((script) => {
					return new Promise((resolve) => {
						const newScript = document.createElement("script");
						if (script.type) {
							newScript.type = script.type;
						}
						newScript.textContent = script.textContent;
						newScript.onload = resolve;
						newScript.onerror = resolve;
						script.parentNode?.replaceChild(newScript, script);
						// 如果脚本已经加载（内联脚本），立即 resolve
						if (!newScript.src) {
							resolve(undefined);
						}
					});
				});

				// 等待所有脚本执行完成
				await Promise.all(scriptPromises);

				if (protectionDiv && protectionDiv.parentNode) {
					protectionDiv.remove();
				}
				contentDiv.style.display = "block";

				// 显示分享组件和版权信息
				const shareComponent =
					document.getElementById("share-component");
				const licenseComponent =
					document.getElementById("license-component");
				if (shareComponent) {
					shareComponent.classList.remove("encrypted-hidden");
				}
				if (licenseComponent) {
					licenseComponent.classList.remove("encrypted-hidden");
				}

				sessionStorage.setItem(
					"page-password-" + window.location.pathname,
					inputPassword,
				);

				// 触发后续处理
				setTimeout(async () => {
					if (window.hljs) {
						contentDiv
							.querySelectorAll("pre code")
							.forEach((block) => {
								window.hljs.highlightElement(block);
							});
					}

					const tocElement =
						document.querySelector("table-of-contents");
					if (
						tocElement &&
						typeof tocElement.regenerateTOC === "function"
					) {
						tocElement.regenerateTOC();
						tocElement.init();
					}

					if (typeof window.mobileTOCInit === "function") {
						window.mobileTOCInit();
					}

					if (typeof Fancybox !== "undefined" && Fancybox.bind) {
						Fancybox.unbind("[data-fancybox]");
						Fancybox.bind("[data-fancybox]", {});
					}

					// 处理 URL 锚点跳转
					if (window.location.hash) {
						const targetId = window.location.hash.substring(1);
						const targetElement = document.getElementById(targetId);
						if (targetElement) {
							targetElement.scrollIntoView({
								behavior: "smooth",
							});
						}
					}

					const images = contentDiv.querySelectorAll("img");
					images.forEach((img) => {
						if (!img.complete) {
							img.addEventListener("load", () => {
								window.dispatchEvent(new Event("scroll"));
								window.dispatchEvent(new Event("resize"));
							});
						}
					});

					[0, 100, 300, 500, 1000, 2000].forEach((delay) => {
						setTimeout(() => {
							window.dispatchEvent(new Event("scroll"));
							window.dispatchEvent(new Event("resize"));
						}, delay);
					});

					// 触发 mermaid 重新渲染
					if (typeof window.renderMermaidDiagrams === "function") {
						await new Promise((resolve) =>
							setTimeout(resolve, 100),
						);
						window.renderMermaidDiagrams();
					}
				}, 50);
			} catch (error) {
				console.error(i18nDecryptionError, error);
				showError(i18nPasswordDecryptRetry);
			} finally {
				if (unlockBtn) {
					unlockBtn.disabled = false;
					unlockBtn.textContent = i18nUnlock;
				}
			}
		}

		function showError(message) {
			errorMessage.textContent = message;
			errorMessage.style.display = "block";
			if (!protectionDiv.classList.contains("auto-unlocking")) {
				passwordInput.focus();
			}
		}

		unlockBtn.addEventListener("click", () => attemptUnlock());
		passwordInput.addEventListener("keypress", (e) => {
			if (e.key === "Enter") attemptUnlock();
		});

		if (savedPassword) {
			attemptUnlock();
		} else {
			passwordInput.focus();
		}
	}

	if (document.readyState === "loading") {
		document.addEventListener("DOMContentLoaded", initPasswordProtection);
	} else {
		initPasswordProtection();
	}
</script>

<script>
	document.addEventListener("click", function (e: MouseEvent) {
		const target = e.target as HTMLElement | null;
		if (!target) return;

		const btn = target.closest(".copy-btn");

		if (btn) {
			const codeEle = btn.parentElement?.querySelector("code");

			if (codeEle) {
				let code = "";

				const lineElements = codeEle.querySelectorAll("span.line");
				if (lineElements.length > 0) {
					const lines: string[] = [];
					for (let i = 0; i < lineElements.length; i++) {
						lines.push(lineElements[i].textContent || "");
					}
					code = lines.join("\n");
				} else {
					const codeElements = codeEle.querySelectorAll(
						".code:not(summary *)",
					);
					if (codeElements.length > 0) {
						const lines: string[] = [];
						for (let i = 0; i < codeElements.length; i++) {
							lines.push(codeElements[i].textContent || "");
						}
						code = lines.join("\n");
					} else {
						code = codeEle.textContent || "";
					}
				}

				code = code.replace(/\n{3,}/g, (match) => {
					const emptyLineCount = match.length - 1;
					const resultEmptyLines = Math.ceil(emptyLineCount / 2);
					return "\n".repeat(resultEmptyLines + 1);
				});

				const copyToClipboard = async (text: string) => {
					try {
						await navigator.clipboard.writeText(text);
					} catch (clipboardErr) {
						console.warn(
							"Clipboard API failed. Try the alternative plan:",
							clipboardErr,
						);
						const textArea = document.createElement("textarea");
						textArea.value = text;
						textArea.style.position = "fixed";
						textArea.style.left = "-999999px";
						textArea.style.top = "-999999px";
						document.body.appendChild(textArea);
						textArea.focus();
						textArea.select();
						try {
							(document as any).execCommand("copy");
						} catch (execErr) {
							console.error("execCommand failed:", execErr);
						} finally {
							document.body.removeChild(textArea);
						}
					}
				};

				copyToClipboard(code)
					.then(() => {
						const timeoutId = btn.getAttribute("data-timeout-id");
						if (timeoutId) {
							clearTimeout(parseInt(timeoutId));
						}

						btn.classList.add("success");

						const newTimeoutId = setTimeout(() => {
							btn.classList.remove("success");
						}, 1000);

						btn.setAttribute(
							"data-timeout-id",
							newTimeoutId.toString(),
						);
					})
					.catch((err) => {
						console.error("copy failed:", err);
					});
			}
		}
	});
</script>
